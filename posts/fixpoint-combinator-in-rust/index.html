<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="index, follow" name=robots><link href=https://noteoverflow.github.io/rss.xml rel=alternate title=RSS type=application/rss+xml><title>noteoverflow | Fix point combinator in Rust</title><link as=style href=https://noteoverflow.github.io/css/style.css rel=preload><link crossorigin href=https://noteoverflow.github.io/css/reset-min.css rel=stylesheet><link crossorigin href=https://noteoverflow.github.io/css/suCSS-min.css rel=stylesheet><link href=https://noteoverflow.github.io/css/style.css rel=stylesheet><link href=https://noteoverflow.github.io/css/custom.css rel=stylesheet><link href=https://noteoverflow.github.io/img/favicon.ico rel=icon><link href=https://noteoverflow.github.io/css/katex.min.css rel=stylesheet><script defer src=https://noteoverflow.github.io/js/katex.min.js></script><script defer src=https://noteoverflow.github.io/js/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded", function() {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: "$$", right: "$$", display: true},
                        {left: "$", right: "$", display: false},
                    ]
                });
            });</script><body><nav id=nav-bar><a href=/> [post] </a><a href=/pinned> [pinned] </a><a href=/tags> [tag] </a><a href=/about> [about] </a>   <div aria-label="Toggle theme" class=theme-toggle data-icon-base=https://noteoverflow.github.io/icons.svg data-icon-dark=#darkMode data-icon-light=#lightMode data-sound-src=https://noteoverflow.github.io/click.ogg id=theme-toggle role=button tabindex=0><svg class=icon><use id=theme-icon></use></svg></div></nav><main><article class=post><header class=post-header><time datetime=2025-04-03>Published on: <span class=accent-data>2025-04-03</span> </time><h1>Fix point combinator in Rust</h1></header><details><summary><i>Table of content</i></summary> <div class=toc-container><ul><li><a href=https://noteoverflow.github.io/posts/fixpoint-combinator-in-rust/#fix-point-of-a-function>Fix point of a function</a><li><a href=https://noteoverflow.github.io/posts/fixpoint-combinator-in-rust/#self-as-parameter>Self as parameter</a> <ul><li><a href=https://noteoverflow.github.io/posts/fixpoint-combinator-in-rust/#repeating-self>Repeating self?</a></ul><li><a href=https://noteoverflow.github.io/posts/fixpoint-combinator-in-rust/#o-combinator>Ω combinator</a><li><a href=https://noteoverflow.github.io/posts/fixpoint-combinator-in-rust/#recursive-type>Recursive type</a> <ul><li><a href=https://noteoverflow.github.io/posts/fixpoint-combinator-in-rust/#simulate-m-type-in-rust>Simulate μ type in rust</a></ul><li><a href=https://noteoverflow.github.io/posts/fixpoint-combinator-in-rust/#y-combinator>Y combinator</a> <ul><li><a href=https://noteoverflow.github.io/posts/fixpoint-combinator-in-rust/#strict-or-lazy>Strict or lazy</a><li><a href=https://noteoverflow.github.io/posts/fixpoint-combinator-in-rust/#application-in-real-world>Application in real world</a></ul><li><a href=https://noteoverflow.github.io/posts/fixpoint-combinator-in-rust/#f-algebras-and-lambek-s-lemma>F-Algebras and Lambek's lemma</a> <ul><li><a href=https://noteoverflow.github.io/posts/fixpoint-combinator-in-rust/#f-algebra>F-Algebra</a><li><a href=https://noteoverflow.github.io/posts/fixpoint-combinator-in-rust/#fix-point-as-the-initial-object>Fix point as the initial object</a></ul></ul></div></details><div class=post-content><p>It has been many years since Haskell discovered the <em>Y</em> combinator(fix point combinator). It's such a milestone that it makes <em>lambda calculus</em> turing complete. Let's try to implement it in Rust and have fun!<h2 id=fix-point-of-a-function>Fix point of a function</h2><p>What do we mean by "fix point"? Well, in fact, it's quite simple. A <em>fix point</em> of a function $f$ is a parameter $x$ with the following equation:<p>$$ f(x) = x $$<p>This does not seem to be fun... But if we try to flip the equation, it's quite interesting:<p>$$ x = f(x) = f(f(x)) = f(f(f(x))) = f^n(x) $$<p>If we can find a fix point, then we have recursion and loops for free! Now suppose we want to build a magic wand Y, for any function $f$, whenever we apply the wand to $f$, we automaically get the fix point of $f$, that is:<p>$$ Y(f) = f(Y(f)) $$<p>$Y(f)$ becomes the fix point of function $f$! But does this magic wand exist? Haskell said <em>YES</em>!</p><center> <img src=/img/blog/fixpoint-combinator-in-rust/y-combinator-mit.png width=400/><br> figure 1 </center><h2 id=self-as-parameter><em>Self</em> as parameter</h2><p>Before we actually find the magic wand, let's first try to consider another question:<blockquote><p>[!NOTE] QUESTION Can we write recursions using pure lambda expressions without name binding?</blockquote><p>For example, if one want to write a recursive factorial function:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>fact</span><span>(</span><span style=color:#bf616a>n</span><span>: </span><span style=color:#b48ead>usize</span><span>) -> </span><span style=color:#b48ead>usize </span><span>{
</span><span>    </span><span style=color:#b48ead>if</span><span> n == </span><span style=color:#d08770>0 </span><span>{
</span><span>        </span><span style=color:#d08770>1
</span><span>    } </span><span style=color:#b48ead>else </span><span>{
</span><span>        n * </span><span style=color:#96b5b4>fact</span><span>(n - </span><span style=color:#d08770>1</span><span>)
</span><span>    }
</span><span>}
</span></code></pre><p>If we cannot use name binding, then we cannot use name <code>fact</code> inside function definition of <code>fact</code>:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>fact</span><span>(</span><span style=color:#bf616a>n</span><span>: </span><span style=color:#b48ead>usize</span><span>) -> </span><span style=color:#b48ead>usize </span><span>{
</span><span>    </span><span style=color:#b48ead>if</span><span> n == </span><span style=color:#d08770>0 </span><span>{
</span><span>        </span><span style=color:#d08770>1
</span><span>    } </span><span style=color:#b48ead>else </span><span>{
</span><span>        n * todo!("</span><span style=color:#a3be8c>how???</span><span>")
</span><span>    }
</span><span>}
</span></code></pre><p>Well, since we cannot directly bind the name, let's try to pass a function as it self:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>fact</span><span>(</span><span style=color:#bf616a>f</span><span>: &dyn Fn(</span><span style=color:#bf616a>usize</span><span>) -> </span><span style=color:#b48ead>usize</span><span>, </span><span style=color:#bf616a>n</span><span>: </span><span style=color:#b48ead>usize</span><span>) -> </span><span style=color:#b48ead>usize </span><span>{
</span><span>    </span><span style=color:#b48ead>if</span><span> n == </span><span style=color:#d08770>0 </span><span>{
</span><span>        </span><span style=color:#d08770>1
</span><span>    } </span><span style=color:#b48ead>else </span><span>{
</span><span>        n * </span><span style=color:#96b5b4>f</span><span>(n - </span><span style=color:#d08770>1</span><span>)
</span><span>    }
</span><span>}
</span></code></pre><p>But the problem still remains. How do we pass the parameter <code>f</code>?<h3 id=repeating-self>Repeating <code>self</code>?</h3><p>In method above we have no way of passing the function of itself <code>f</code>. But we may imitate the function call itself:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>fact</span><span>(</span><span style=color:#bf616a>this</span><span>: &dyn Fn(</span><span style=color:#bf616a>todo</span><span>!("?"), </span><span style=color:#b48ead>usize</span><span>) -> </span><span style=color:#b48ead>usize</span><span>, n: </span><span style=color:#b48ead>usize</span><span>) -> </span><span style=color:#b48ead>usize </span><span>{
</span><span>    </span><span style=color:#b48ead>if</span><span> n == </span><span style=color:#d08770>0 </span><span>{
</span><span>        </span><span style=color:#d08770>1
</span><span>    } </span><span style=color:#b48ead>else </span><span>{
</span><span>        n * </span><span style=color:#96b5b4>this</span><span>(this, n - </span><span style=color:#d08770>1</span><span>)
</span><span>    }
</span><span>}
</span></code></pre><p>No way out. If we are in dynamic typed languages then we are done. But in static typed language like <em>rust</em>, we cannot express the type of <code>this</code>. To see why, consider expand the type of <code>this</code>:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span>this: &dyn Fn(&dyn Fn(todo!("</span><span style=color:#a3be8c>?</span><span>"), </span><span style=color:#b48ead>usize</span><span>) -> </span><span style=color:#b48ead>usize</span><span>, </span><span style=color:#b48ead>usize</span><span>) -> </span><span style=color:#b48ead>usize
</span><span>this: &dyn Fn(&dyn Fn(&dyn Fn(todo!("</span><span style=color:#a3be8c>?</span><span>"), </span><span style=color:#b48ead>usize</span><span>) -> </span><span style=color:#b48ead>usize</span><span>, </span><span style=color:#b48ead>usize</span><span>) -> </span><span style=color:#b48ead>usize</span><span>, </span><span style=color:#b48ead>usize</span><span>) -> </span><span style=color:#b48ead>usize
</span><span style=color:#65737e>//...
</span></code></pre><p>We are repeating the type again and again which leads to <em>inifnite type</em>!<h2 id=o-combinator>Ω combinator</h2><p>Typing is hard. Let's for now forget about types and focus on finding the general way to do recursion in dynamic typed languages. We are now convinced that recursion can definitely be implemented without name binding in dynamic typed languages(see <a href=https://noteoverflow.github.io/posts/fixpoint-combinator-in-rust/#repeating-self>previous section</a>).<p>Recall the pattern of <code>repeating self</code>, we can pass the function itself into itself:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>λf. f(f)
</span></code></pre><p>which looks weird. But remember in this way we can pass the function itself into <code>f</code>? Let try to pass it:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>(λf. f(f))(λf. f(f))
</span></code></pre><p>and try to reduce it(replace f in the first lambda with the passed parameter):<pre style=color:#c0c5ce;background-color:#2b303b><code><span>(λf. f(f))(λf. f(f))
</span></code></pre><p>WOW we just get the original expression back! This kind of combinator is so interesting that we call it the Ω combinator:<p>$$ \omega(x) = x(x) $$<blockquote><p>omega => OMG it's a recursion without name binding!</blockquote><h2 id=recursive-type>Recursive type</h2><blockquote><p>Typing is hard.</blockquote><p>We are now getting really close to the real <em>magic wand</em>! But we still need to fix the <em>infinite type</em> problem.<p>Remember, whenever you find something not exist, just create it! Let's create the <code>infinite type</code> in rust's type system. The first step of any creation if to try to express it in some way. Since we cannot directly express the <em>inifinity</em>, we pass the repeating part as parameter:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>λa.e
</span></code></pre><p>Then we define a new operation <code>unfold</code>:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>unfold (λa.e) = e[(λa.e)/a]
</span></code></pre><p><code>e[a/b]</code> means to replace all occurences of <code>b</code> to <code>a</code>. Therefore we replace all <code>a</code>s into <code>λa.e</code> it self. We can infinitely <code>unfold</code> the type as many times as we want.<p>In theory study, people call this kind of infinite type μ type and replace λ with μ:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>μa.e
</span></code></pre><h3 id=simulate-m-type-in-rust>Simulate μ type in rust</h3><p>Let's implement μ type in Rust! Recall the unimplemented type is like:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span>&dyn Fn(todo!("</span><span style=color:#a3be8c>?</span><span>"), A) -> B
</span></code></pre><p>Then we can create the <code>U</code> type:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>struct </span><span>U&lt;</span><span style=color:#b48ead>'u</span><span>, A, B>(&</span><span style=color:#b48ead>'u</span><span> dyn Fn(U&lt;</span><span style=color:#b48ead>'u</span><span>, A, B>, A) -> B);
</span></code></pre><p>Now we have typed Ω combinator:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>w</span><span>&lt;A, B>(</span><span style=color:#bf616a>u</span><span>: &U&lt;'_, A, B>, </span><span style=color:#bf616a>a</span><span>: A) -> B {
</span><span>    u.</span><span style=color:#d08770>0</span><span>(U(u.</span><span style=color:#d08770>0</span><span>), a) </span><span style=color:#65737e>// f(f, a)
</span><span>}
</span></code></pre><h2 id=y-combinator>Y combinator</h2><p>We've got all prerequisites of our <em>magic wand</em>! Recall the Y combinator we want has the property:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>Y(f) = f(Y(f))
</span></code></pre><p>To achieve this, we only need to add one <code>f</code> to the Ω combinator:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>λx. f(x(x))
</span></code></pre><p>and pass this part to itself:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>(λx. f(x(x)))(λx. f(x(x)))
</span><span>= f((λx. f(x(x)))(λx. f(x(x))))
</span><span>= f(f((λx. f(x(x)))(λx. f(x(x)))))
</span><span>= f(f(f((λx. f(x(x)))(λx. f(x(x))))))
</span><span>= ...
</span></code></pre><p>Believe it or not, we've created the Y combinator! Just abstract <code>f</code>:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>λf. (λx. f(x(x)))(λx. f(x(x)))
</span></code></pre><h3 id=strict-or-lazy>Strict or lazy</h3><p>If you implement the Y combinator above(try it!), you will find that the calculation will <em>stack overflow</em>! This is because this kind of version only can be applied to <em>lazy evaluated</em> language like <em>Haskell</em>. If we want to implement it in Rust, we have to choose a <em>strictly evaluated</em> version. Here's one:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>λf. (λx. f(λa. x(x, a)))(λx. f(λa. x(x, a)))
</span></code></pre><p>Using this we can finally implement the Y combinator in Rust!<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>struct </span><span>U&lt;</span><span style=color:#b48ead>'u</span><span>, A, B>(&</span><span style=color:#b48ead>'u</span><span> dyn Fn(U&lt;</span><span style=color:#b48ead>'u</span><span>, A, B>, A) -> B);
</span><span>
</span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>w</span><span>&lt;A, B>(</span><span style=color:#bf616a>u</span><span>: &U&lt;'_, A, B>, </span><span style=color:#bf616a>a</span><span>: A) -> B {
</span><span>    u.</span><span style=color:#d08770>0</span><span>(U(u.</span><span style=color:#d08770>0</span><span>), a)
</span><span>}
</span><span>
</span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>y</span><span>&lt;A, B>(</span><span style=color:#bf616a>f</span><span>: &impl Fn(&</span><span style=color:#bf616a>dyn Fn</span><span>(</span><span style=color:#bf616a>A</span><span>) -> B, A) -> B, a: A) -> B {
</span><span>    </span><span style=color:#96b5b4>w</span><span>(&U(&|u, a| </span><span style=color:#96b5b4>f</span><span>(&|a| </span><span style=color:#96b5b4>w</span><span>(&u, a), a)), a) </span><span style=color:#65737e>//(λx. f(λa. x(x, a)))(λx. f(λa. x(x, a)))
</span><span>}
</span><span>
</span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>usage</span><span>() {
</span><span>    </span><span style=color:#b48ead>let </span><span style=color:#8fa1b3>fact </span><span>= |</span><span style=color:#bf616a>f</span><span>: &dyn Fn(</span><span style=color:#b48ead>usize</span><span>) -> </span><span style=color:#b48ead>usize</span><span>, </span><span style=color:#bf616a>i</span><span>| {
</span><span>        </span><span style=color:#b48ead>if</span><span> i == </span><span style=color:#d08770>0 </span><span>{
</span><span>            </span><span style=color:#d08770>1
</span><span>        } </span><span style=color:#b48ead>else </span><span>{
</span><span>            i * </span><span style=color:#96b5b4>f</span><span>(i - </span><span style=color:#d08770>1</span><span>)
</span><span>        }
</span><span>    };
</span><span>
</span><span>    </span><span style=color:#b48ead>let</span><span> n = </span><span style=color:#96b5b4>y</span><span>(&fact, </span><span style=color:#d08770>5</span><span>);
</span><span>    assert_eq!(n, </span><span style=color:#d08770>120</span><span>);
</span><span>}
</span></code></pre><h3 id=application-in-real-world>Application in real world</h3><p>At first glance, you may assume recursion without name binding is useless.<blockquote><p>[!NOTE] QUESTION What's the point of abstracting recursion this way if we can use name binding directly?</blockquote><p>I used to assume that the Y combinator can only be useful in theory analysis. But I'm wrong. The power of fix point arises when we try to abstract general effects!<h4 id=memorizing-fibbonacci>Memorizing fibbonacci</h4><p>The fibbonacci series has a direct recursion implementation (in rust, for example):<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>fib</span><span>(</span><span style=color:#bf616a>i</span><span>: </span><span style=color:#b48ead>usize</span><span>) -> </span><span style=color:#b48ead>usize </span><span>{
</span><span>    </span><span style=color:#b48ead>if</span><span> i &lt;= </span><span style=color:#d08770>1 </span><span>{
</span><span>        </span><span style=color:#d08770>1
</span><span>    } </span><span style=color:#b48ead>else </span><span>{
</span><span>        </span><span style=color:#96b5b4>fib</span><span>(i - </span><span style=color:#d08770>1</span><span>) + </span><span style=color:#96b5b4>fib</span><span>(i - </span><span style=color:#d08770>2</span><span>)
</span><span>    }
</span><span>}
</span></code></pre><p>However, since <code>fib</code> is not efficient and has already been a fixed point, we cannot transform it into memorization version(i.e., the state side-effect):<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>mfib</span><span>() -> impl FnMut(</span><span style=color:#b48ead>usize</span><span>) -> </span><span style=color:#b48ead>usize </span><span>{
</span><span>    </span><span style=color:#b48ead>let mut</span><span> cache = HashMap::new();
</span><span>    </span><span style=color:#b48ead>move </span><span>|i| </span><span style=color:#b48ead>match</span><span> cache.</span><span style=color:#96b5b4>get</span><span>(&i) {
</span><span>        Some(n) => *n,
</span><span>        None => {
</span><span>            </span><span style=color:#b48ead>let</span><span> n = </span><span style=color:#96b5b4>fib</span><span>(i);
</span><span>            cache.</span><span style=color:#96b5b4>insert</span><span>(i, n);
</span><span>            n
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p><code>mfib</code> is still $O(2^n)$! If a function has already been fixed as a fix point, we cannot change its complexity! Therefore there's no way we can reuse <code>fib</code>.<p>Applying the fix point combinator, we can abstract the function itself:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>trait </span><span>Fib {
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>run</span><span>(&</span><span style=color:#b48ead>mut </span><span style=color:#bf616a>self</span><span>, </span><span style=color:#bf616a>i</span><span>: </span><span style=color:#b48ead>usize</span><span>) -> </span><span style=color:#b48ead>usize</span><span>;
</span><span>}
</span><span>
</span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>fib</span><span>&lt;F: Fib>(</span><span style=color:#bf616a>f</span><span>: &</span><span style=color:#b48ead>mut</span><span> F, </span><span style=color:#bf616a>i</span><span>: </span><span style=color:#b48ead>usize</span><span>) -> </span><span style=color:#b48ead>usize </span><span>{
</span><span>    </span><span style=color:#b48ead>if</span><span> i &lt;= </span><span style=color:#d08770>1 </span><span>{
</span><span>        </span><span style=color:#d08770>1
</span><span>    } </span><span style=color:#b48ead>else </span><span>{
</span><span>        f.</span><span style=color:#96b5b4>run</span><span>(i - </span><span style=color:#d08770>1</span><span>) + f.</span><span style=color:#96b5b4>run</span><span>(i - </span><span style=color:#d08770>2</span><span>)
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#b48ead>struct </span><span>MemFib {
</span><span>    </span><span style=color:#bf616a>cache</span><span>: HashMap&lt;</span><span style=color:#b48ead>usize</span><span>, </span><span style=color:#b48ead>usize</span><span>>,
</span><span>}
</span><span>
</span><span style=color:#b48ead>impl </span><span>MemFib {
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>new</span><span>() -> </span><span style=color:#b48ead>Self </span><span>{
</span><span>        </span><span style=color:#b48ead>Self </span><span>{
</span><span>            cache: HashMap::new(),
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#b48ead>impl </span><span>Fib </span><span style=color:#b48ead>for </span><span>MemFib {
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>run</span><span>(&</span><span style=color:#b48ead>mut </span><span style=color:#bf616a>self</span><span>, </span><span style=color:#bf616a>i</span><span>: </span><span style=color:#b48ead>usize</span><span>) -> </span><span style=color:#b48ead>usize </span><span>{
</span><span>        </span><span style=color:#b48ead>match </span><span style=color:#bf616a>self</span><span>.cache.</span><span style=color:#96b5b4>get</span><span>(&i) {
</span><span>            Some(n) => *n,
</span><span>            None => {
</span><span>                </span><span style=color:#b48ead>let</span><span> n = </span><span style=color:#96b5b4>fib</span><span>(</span><span style=color:#bf616a>self</span><span>, i);
</span><span>                </span><span style=color:#bf616a>self</span><span>.cache.</span><span style=color:#96b5b4>insert</span><span>(i, n);
</span><span>                n
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>test_mfib</span><span>() {
</span><span>    </span><span style=color:#b48ead>let mut</span><span> mfib = MemFib::new();
</span><span>    </span><span style=color:#b48ead>let</span><span> n = </span><span style=color:#96b5b4>fib</span><span>(&</span><span style=color:#b48ead>mut</span><span> mfib, </span><span style=color:#d08770>50</span><span>);
</span><span>    dbg!(n);
</span><span>}
</span></code></pre><p>Now we can safely reuse the <code>fib</code> function and reduce its time complexity to $O(n)$.<p>Notably, if you still want the original naive pure recursive version of fib, you can still build it as:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>struct </span><span>NaiveFib;
</span><span>
</span><span style=color:#b48ead>impl </span><span>Fib </span><span style=color:#b48ead>for </span><span>NaiveFib {
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>run</span><span>(&</span><span style=color:#b48ead>mut </span><span style=color:#bf616a>self</span><span>, </span><span style=color:#bf616a>i</span><span>: </span><span style=color:#b48ead>usize</span><span>) -> </span><span style=color:#b48ead>usize </span><span>{
</span><span>        </span><span style=color:#96b5b4>fib</span><span>(</span><span style=color:#bf616a>self</span><span>, i)
</span><span>    }
</span><span>}
</span></code></pre><p>Finally, the <code>fib</code> function is composable both in pure fix point, but also in other effects!<h2 id=f-algebras-and-lambek-s-lemma>F-Algebras and Lambek's lemma</h2><p>Have you ever been curious that why recursion has been so useful and unbiquitous? Or, have you ever been curious that why products and coproducts are so important in both programming and math? Interestingly, there is strong explanation in category theory!<h3 id=f-algebra>F-Algebra</h3><p>Have you ever doubt the definiton of "algebra"? Mathematicians use the word "algebra" everywhere. In category theory, we abstract various kinds of algebras as <em>F-Algebra</em>: $$ F(a) \rightarrow a $$<p>For example, to represent <em>Monoid m</em>, we need two operations:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>0: m
</span><span>plus: m -> m -> m
</span><span>
</span><span>a + b = plus a b
</span></code></pre><p>Then we can define $F(a)$ as: $$ F(m) = m^1 \times m^{m \times m} $$<h3 id=fix-point-as-the-initial-object>Fix point as the initial object</h3><p>Now that we have definition of algebras, does this definiton look familiar to you?<p>Recall the definition of fix point: $$ f(a) = a $$<p>The definition of F-Algebra only replace the <code>=</code> symbol to arrow! We can define an operator <code>fix</code> just as μ type:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>type Fix f = Fix (f (Fix f))
</span></code></pre><p>Then define operators:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>fix: f (Fix f) -> Fix f
</span><span>unfix: Fix f -> f (Fix f)
</span></code></pre><p>You may now ask: What's the point of abstracting fix point this way? The secret lies in the relations of different kinds of F-algebras!<p>Suppose you have two F-algebras:<p>$$ F(a) \rightarrow a $$ $$ F(b) \rightarrow b $$<p>Viewing $F(a) \rightarrow a$ as one object, then we can define relations between $F(a) \rightarrow a$ and $F(b) \rightarrow b$ as: $$ f: a \rightarrow b $$ $$ (map\ f): F(a) \rightarrow F(b) $$<p>To better demonstrate the relation, we can use <em>commutative diagram</em>:</p><center> <img src=/img/blog/fixpoint-combinator-in-rust/f-algebra-relation.png width=400/><br> figure 2 </center><br><p>If this diagram commutes, we say that we have relation $f$ from $F(a) \rightarrow a$ to $F(b) \rightarrow b$. Various kinds of F-algebras and relations between them forms a category! Now we ask an interesting question:<blockquote><p>[!NOTE] QUESTION Does this category have initial object? By <em>initial object</em>, we mean that, is there an object from which only exists one arrow to any other objects?</blockquote><p>If we have this kind of initial object $F(x) \rightarrow x$, then we can prove that $x$ is a fix point of $F$ and: $$ F(x) = x $$ Instead of arrow, this time we have the final equality! Now we can conclude that recursion is important because it's the initial object in the category of algebras! and initial object implies some universal optimal construct!<p>If you are interested at the proof, try to follow the commutative diagram below!</p><center> <img src=/img/blog/fixpoint-combinator-in-rust/lambek-lemma.png width=300/><br> lambek lemma proof </center><br></div><div class=post-tags><a class=tag href=/tags/plt>#plt </a><a class=tag href=/tags/rust>#rust </a><a class=tag href=/tags/programming>#programming </a></div></article></main><footer><hr><div id=footer-container><i><a href=/test>Q.E.D.</a></i></div><br></footer><script defer src=https://noteoverflow.github.io/js/script.js></script>