<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="index, follow" name=robots><link href=https://noteoverflow.github.io/rss.xml rel=alternate title=RSS type=application/rss+xml><title>noteoverflow | Linear algebraic effects in Rust</title><link as=style href=https://noteoverflow.github.io/css/style.css rel=preload><link crossorigin href=https://noteoverflow.github.io/css/reset-min.css rel=stylesheet><link crossorigin href=https://noteoverflow.github.io/css/suCSS-min.css rel=stylesheet><link href=https://noteoverflow.github.io/css/style.css rel=stylesheet><link href=https://noteoverflow.github.io/css/custom.css rel=stylesheet><link href=https://noteoverflow.github.io/img/favicon.ico rel=icon><body><nav id=nav-bar><a href=/posts> [post] </a><a href=/pinned> [pin] </a><a href=/tags> [tag] </a><a href=/> [self] </a> Â  <div aria-label="Toggle theme" class=theme-toggle data-icon-base=https://noteoverflow.github.io/icons.svg data-icon-dark=#darkMode data-icon-light=#lightMode data-sound-src=https://noteoverflow.github.io/click.ogg id=theme-toggle role=button tabindex=0><svg class=icon><use id=theme-icon></use></svg></div></nav><main><article class=post><header class=post-header><time datetime=2025-03-29>Published on: <span class=accent-data>2025-03-29</span> </time><div class=post-tags><a class=tag href=/tags/rust>#rust </a><a class=tag href=/tags/programming>#programming </a><a class=tag href=/tags/effect-system>#effect-system </a></div><h1>Linear algebraic effects in Rust</h1></header><details><summary><i>Table of content</i></summary> <div class=toc-container><ul><li><a href=https://noteoverflow.github.io/posts/linear-algebraic-effect-in-rust/#the-experimental-coroutine-trait>The experimental Coroutine trait</a><li><a href=https://noteoverflow.github.io/posts/linear-algebraic-effect-in-rust/#yield-as-effects>Yield as effects</a><li><a href=https://noteoverflow.github.io/posts/linear-algebraic-effect-in-rust/#composing-effectful-programs>Composing effectful programs</a><li><a href=https://noteoverflow.github.io/posts/linear-algebraic-effect-in-rust/#epilogue>Epilogue</a></ul></div></details><div class=post-content><p>Recently I successfully implement <em>Linear Algebraic Effect(Linear AE)</em> in Rust! You may ask, what exactly is <em>Linear AE</em>? Well, honestly, the word 'linear' is used by myself to mean <em>one-shot</em>, which implies the effect cannot be cloned casually. <em>AE</em> is a special kind of structure like "exceptions can return". I'm not going to explain <em>AE</em> in detail in this post. Let's jump into rust's implementation!<h2 id=the-experimental-coroutine-trait>The experimental <code>Coroutine</code> trait</h2><p>Yes rust already has a trait called <code>Coroutine</code> whose definition is:<pre class=language-rust data-lang=rust style=color:#ccc9c2;background-color:#212733><code class=language-rust data-lang=rust><span style=color:#ffa759>pub trait </span><span style=color:#73d0ff>Coroutine</span><span>&lt;R = ()> {
</span><span>    </span><span style=color:#ffa759>type </span><span style=color:#73d0ff>Yield</span><span style=color:#ccc9c2cc>;
</span><span>    </span><span style=color:#ffa759>type </span><span style=color:#73d0ff>Return</span><span style=color:#ccc9c2cc>;
</span><span>
</span><span>    </span><span style=color:#ffa759>fn </span><span style=color:#ffd580>resume</span><span>(</span><span style=color:#fc6>self</span><span>: Pin&lt;</span><span style=color:#f29e74>&</span><span style=color:#ffa759>mut Self</span><span>>, </span><span style=color:#fc6>arg</span><span style=color:#ccc9c2cc>:</span><span> R) </span><span style=color:#ccc9c2cc>-> </span><span>CoroutineState&lt;</span><span style=color:#ffa759>Self</span><span style=color:#f29e74>::</span><span>Yield, </span><span style=color:#ffa759>Self</span><span style=color:#f29e74>::</span><span>Return></span><span style=color:#ccc9c2cc>;
</span><span>}
</span></code></pre><p>The associated type <code>Coroutine::Yield</code> means the yielded type of the coroutine and the type <code>Coroutine::Return</code> refers to the type of returned value. For example:<pre class=language-rust data-lang=rust style=color:#ccc9c2;background-color:#212733><code class=language-rust data-lang=rust><span style=color:#ffa759>let</span><span> generator </span><span style=color:#f29e74>= </span><span style=color:#ccc9c2cc>#</span><span>[</span><span style=color:#ffd580>coroutine</span><span>] </span><span style=color:#f29e74>|| </span><span>{
</span><span>    </span><span style=color:#ffa759>for</span><span> i </span><span style=color:#f29e74>in </span><span style=color:#fc6>0</span><span style=color:#f29e74>..</span><span style=color:#fc6>10 </span><span>{
</span><span>        </span><span style=color:#f33>yield</span><span> i</span><span style=color:#ccc9c2cc>;
</span><span>    }
</span><span>}
</span></code></pre><p>The generated coroutine <code>generator</code> acts like a simple iterator which <em>yields</em> integers from 0 to 10. Therefore the <code>Yield</code> type of <code>generator</code> is <code>i32</code> and type <code>Return</code> is <code>()</code>.<p>Now let's focus on the method <code>Corouine::resume</code>. <code>resume</code> takes a <em>pinned self</em> since the coroutine itself may contain self-referential pointers just like those in <code>Future</code>. Every time one resume with a parameter, the coroutine returns a <code>CoroutineState</code> to indicate whether it should return or yield. For instance:<pre class=language-rust data-lang=rust style=color:#ccc9c2;background-color:#212733><code class=language-rust data-lang=rust><span style=color:#ffa759>let mut</span><span> coroutine </span><span style=color:#f29e74>= </span><span style=color:#ccc9c2cc>#</span><span>[</span><span style=color:#ffd580>coroutine</span><span>] </span><span style=color:#f29e74>|| </span><span>{
</span><span>    </span><span style=color:#f33>yield </span><span style=color:#fc6>1</span><span style=color:#ccc9c2cc>;
</span><span>    </span><span style=color:#bae67e>"foo"
</span><span>}</span><span style=color:#ccc9c2cc>;
</span><span>
</span><span style=color:#ffa759>match </span><span>Pin</span><span style=color:#f29e74>::</span><span>new(</span><span style=color:#f29e74>&</span><span style=color:#ffa759>mut</span><span> coroutine)</span><span style=color:#f29e74>.</span><span style=color:#f28779>resume</span><span>(()) {
</span><span>    CoroutineState</span><span style=color:#f29e74>::</span><span>Yielded(</span><span style=color:#fc6>1</span><span>) </span><span style=color:#f29e74>=> </span><span>{}
</span><span>    </span><span style=color:#f29e74>_ => </span><span style=color:#f28779>panic!</span><span>(</span><span style=color:#bae67e>"unexpected return from resume"</span><span>)</span><span style=color:#ccc9c2cc>,
</span><span>}
</span><span style=color:#ffa759>match </span><span>Pin</span><span style=color:#f29e74>::</span><span>new(</span><span style=color:#f29e74>&</span><span style=color:#ffa759>mut</span><span> coroutine)</span><span style=color:#f29e74>.</span><span style=color:#f28779>resume</span><span>(()) {
</span><span>    CoroutineState</span><span style=color:#f29e74>::</span><span>Complete(</span><span style=color:#bae67e>"foo"</span><span>) </span><span style=color:#f29e74>=> </span><span>{}
</span><span>    </span><span style=color:#f29e74>_ => </span><span style=color:#f28779>panic!</span><span>(</span><span style=color:#bae67e>"unexpected return from resume"</span><span>)</span><span style=color:#ccc9c2cc>,
</span><span>}
</span></code></pre><h2 id=yield-as-effects><code>Yield</code> as effects</h2><p>Since rust's compiler can automatically transform our coroutine into a stackless state machine, we can directly utilize it's <code>Yield</code> type to implement effects!<p>Consider a common <em>logging</em> effect, let's define it as a common data strucutre:<pre class=language-rust data-lang=rust style=color:#ccc9c2;background-color:#212733><code class=language-rust data-lang=rust><span style=color:#ffa759>struct </span><span style=color:#73d0ff>Log</span><span>(String)</span><span style=color:#ccc9c2cc>;
</span></code></pre><p>The we can create a coroutine to yield <code>Log</code>:<pre class=language-rust data-lang=rust style=color:#ccc9c2;background-color:#212733><code class=language-rust data-lang=rust><span style=color:#ffa759>let</span><span> may_log </span><span style=color:#f29e74>= </span><span style=color:#ccc9c2cc>#</span><span>[</span><span style=color:#ffd580>coroutine</span><span>] </span><span style=color:#f29e74>|</span><span>i</span><span style=color:#ccc9c2cc>: </span><span style=color:#ffa759>usize</span><span style=color:#f29e74>| </span><span>{
</span><span>    </span><span style=color:#ffa759>if</span><span> i </span><span style=color:#f29e74>== </span><span style=color:#fc6>0 </span><span>{
</span><span>        </span><span style=color:#f33>yield</span><span> Log(</span><span style=color:#bae67e>"i == 0"</span><span style=color:#f29e74>.</span><span style=color:#f28779>to_string</span><span>())</span><span style=color:#ccc9c2cc>;
</span><span>    }
</span><span>}
</span></code></pre><p>If you try to write <code>may_log</code>'s type, You will find that the <code>Yield</code> type can indicate that, while executing the coroutine, it may yield <em>logging</em>:<pre class=language-rust data-lang=rust style=color:#ccc9c2;background-color:#212733><code class=language-rust data-lang=rust><span>may_log</span><span style=color:#ccc9c2cc>: </span><span style=color:#ffa759>usize </span><span style=color:#ccc9c2cc>-> </span><span>() yields Log
</span></code></pre><p>Notably, <code>yield</code> is a expression which can return value which will be filled as parameters while resuming.<p>Let's abstract this pattern a little. Firstly, we can model effects as various kinds of data such as<pre class=language-rust data-lang=rust style=color:#ccc9c2;background-color:#212733><code class=language-rust data-lang=rust><span style=color:#ffa759>enum </span><span style=color:#73d0ff>Effect </span><span>{
</span><span>    Log(</span><span style=color:#5ccfe6;font-style:italic>String</span><span>)</span><span style=color:#ccc9c2cc>,
</span><span>    State(State)</span><span style=color:#ccc9c2cc>,
</span><span>    Async</span><span style=color:#ccc9c2cc>,
</span><span>    Injection</span><span style=color:#ccc9c2cc>,
</span><span>    </span><span style=color:#5c6773;font-style:italic>//...
</span><span>}
</span></code></pre><p>Then we write our program logic as a coroutine which yields its requiring effect:<pre class=language-rust data-lang=rust style=color:#ccc9c2;background-color:#212733><code class=language-rust data-lang=rust><span style=color:#ccc9c2cc>#</span><span>[</span><span style=color:#ffd580>coroutine</span><span>] </span><span style=color:#f29e74>|</span><span>arg</span><span style=color:#ccc9c2cc>:</span><span> I</span><span style=color:#f29e74>| </span><span style=color:#ccc9c2cc>-></span><span> R {
</span><span>    </span><span style=color:#ffa759>let</span><span> a </span><span style=color:#f29e74>= </span><span style=color:#f33>yield </span><span>Effect</span><span style=color:#f29e74>::</span><span>Log(</span><span style=color:#bae67e>"a"</span><span style=color:#f29e74>.</span><span style=color:#f28779>to_string</span><span>())</span><span style=color:#ccc9c2cc>;
</span><span>    </span><span style=color:#ffa759>let</span><span> b </span><span style=color:#f29e74>= </span><span style=color:#f33>yield </span><span>Effect</span><span style=color:#f29e74>::</span><span>State(State</span><span style=color:#f29e74>::</span><span>Get)</span><span style=color:#ccc9c2cc>;
</span><span>    </span><span style=color:#f33>yield </span><span>Effect</span><span style=color:#f29e74>::</span><span>State(State</span><span style=color:#f29e74>::</span><span>Set(</span><span style=color:#fc6>0</span><span>))</span><span style=color:#ccc9c2cc>;
</span><span>    </span><span style=color:#ffa759>let</span><span> c </span><span style=color:#f29e74>= </span><span style=color:#f33>yield </span><span>Effect</span><span style=color:#f29e74>::</span><span>Async</span><span style=color:#ccc9c2cc>,
</span><span>    </span><span style=color:#5c6773;font-style:italic>//...
</span><span>}
</span></code></pre><p>Finally, we write a data structure to resume the coroutine until it returns.<h2 id=composing-effectful-programs>Composing effectful programs</h2><p>We can now create effectful programs. But how can we compose them? Coroutines are not like normal functions, they will not return until it yields all effects. If we write:<pre class=language-rust data-lang=rust style=color:#ccc9c2;background-color:#212733><code class=language-rust data-lang=rust><span style=color:#ffa759>let</span><span> a </span><span style=color:#f29e74>= </span><span style=color:#f28779>coroutine</span><span>(arg)</span><span style=color:#ccc9c2cc>;
</span></code></pre><p>We are expecting <code>a</code> as the returned result of calling <code>coroutine</code>. Therefore we need to comsume all its effects:<pre class=language-rust data-lang=rust style=color:#ccc9c2;background-color:#212733><code class=language-rust data-lang=rust><span style=color:#ffa759>let</span><span> a </span><span style=color:#f29e74>= </span><span>{
</span><span>    </span><span style=color:#ffa759>let mut</span><span> pinned </span><span style=color:#f29e74>= </span><span style=color:#f28779>pin!</span><span>(coroutine)</span><span style=color:#ccc9c2cc>;
</span><span>    </span><span style=color:#ffa759>let mut</span><span> arg </span><span style=color:#f29e74>=</span><span> arg</span><span style=color:#ccc9c2cc>;
</span><span>    </span><span style=color:#ffa759>loop </span><span>{
</span><span>        </span><span style=color:#ffa759>let</span><span> res </span><span style=color:#f29e74>=</span><span> pinned</span><span style=color:#f29e74>.</span><span style=color:#f28779>as_mut</span><span>()</span><span style=color:#f29e74>.</span><span style=color:#f28779>resume</span><span>(arg)</span><span style=color:#ccc9c2cc>;
</span><span>        </span><span style=color:#ffa759>match</span><span> res {
</span><span>            CoroutineState</span><span style=color:#f29e74>::</span><span>Yielded(eff) </span><span style=color:#f29e74>=> </span><span>{
</span><span>                arg </span><span style=color:#f29e74>= </span><span style=color:#f33>yield</span><span> eff</span><span style=color:#ccc9c2cc>;
</span><span>            }
</span><span>            CoroutineState</span><span style=color:#f29e74>::</span><span>Complete(v) </span><span style=color:#f29e74>=> </span><span style=color:#ffa759>break</span><span> v</span><span style=color:#ccc9c2cc>,
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>This is also a common pattern, so let's write a macro:<pre class=language-rust data-lang=rust style=color:#ccc9c2;background-color:#212733><code class=language-rust data-lang=rust><span style=color:#f28779>macro_rules! </span><span style=color:#73d0ff>run </span><span>{
</span><span>    (</span><span style=color:#fc6>$f</span><span style=color:#ccc9c2cc>:</span><span style=color:#ffa759>expr</span><span>, </span><span style=color:#fc6>$arg</span><span style=color:#ccc9c2cc>:</span><span style=color:#ffa759>expr</span><span>) </span><span style=color:#f29e74>=> </span><span>{{
</span><span>        </span><span style=color:#ffa759>let mut</span><span> pinned </span><span style=color:#f29e74>= </span><span style=color:#f28779>pin!</span><span>($f)</span><span style=color:#ccc9c2cc>;
</span><span>        </span><span style=color:#ffa759>let mut</span><span> arg </span><span style=color:#f29e74>= </span><span>$arg</span><span style=color:#ccc9c2cc>;
</span><span>        </span><span style=color:#ffa759>loop </span><span>{
</span><span>            </span><span style=color:#ffa759>let</span><span> res </span><span style=color:#f29e74>=</span><span> pinned</span><span style=color:#f29e74>.</span><span style=color:#f28779>as_mut</span><span>()</span><span style=color:#f29e74>.</span><span style=color:#f28779>resume</span><span>(arg)</span><span style=color:#ccc9c2cc>;
</span><span>            </span><span style=color:#ffa759>match</span><span> res {
</span><span>                CoroutineState</span><span style=color:#f29e74>::</span><span>Yielded(eff) </span><span style=color:#f29e74>=> </span><span>{
</span><span>                    arg </span><span style=color:#f29e74>= </span><span style=color:#f33>yield</span><span> eff</span><span style=color:#ccc9c2cc>;
</span><span>                }
</span><span>                CoroutineState</span><span style=color:#f29e74>::</span><span>Complete(v) </span><span style=color:#f29e74>=> </span><span style=color:#ffa759>break</span><span> v</span><span style=color:#ccc9c2cc>,
</span><span>            }
</span><span>        }
</span><span>    }}</span><span style=color:#ccc9c2cc>;
</span><span>}
</span></code></pre><p>Now we can simply write to compose effectful programs:<pre class=language-rust data-lang=rust style=color:#ccc9c2;background-color:#212733><code class=language-rust data-lang=rust><span style=color:#ffa759>let</span><span> a </span><span style=color:#f29e74>= </span><span style=color:#f28779>run!</span><span>(coroutine</span><span style=color:#ccc9c2cc>,</span><span> arg)</span><span style=color:#ccc9c2cc>;
</span></code></pre><h2 id=epilogue>Epilogue</h2><p>This a demo implementation of algebraic effect in Rust. There is a better version with <em>Handlers</em> in <a href=https://crates.io/crates/algoroutine>crates.io/algoroutine</a>.</div></article></main><footer><br><div id=footer-container><i><a href=/internal/test>Q.E.D.</a></i></div><br></footer><script defer src=https://noteoverflow.github.io/js/script.js></script><div class=comments></div>