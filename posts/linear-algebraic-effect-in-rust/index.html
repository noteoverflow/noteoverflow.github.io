<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="index, follow" name=robots><link href=https://noteoverflow.github.io/rss.xml rel=alternate title=RSS type=application/rss+xml><title>noteoverflow | Linear algebraic effects in Rust</title><link as=style href=https://noteoverflow.github.io/css/style.css rel=preload><link crossorigin href=https://noteoverflow.github.io/css/reset-min.css rel=stylesheet><link crossorigin href=https://noteoverflow.github.io/css/suCSS-min.css rel=stylesheet><link href=https://noteoverflow.github.io/css/style.css rel=stylesheet><link href=https://noteoverflow.github.io/css/custom.css rel=stylesheet><link href=https://noteoverflow.github.io/img/favicon.ico rel=icon><body><nav id=nav-bar><a href=/> [post] </a><a href=/pinned> [pinned] </a><a href=/tags> [tag] </a><a href=/about> [about] </a> Â  <div aria-label="Toggle theme" class=theme-toggle data-icon-base=https://noteoverflow.github.io/icons.svg data-icon-dark=#darkMode data-icon-light=#lightMode data-sound-src=https://noteoverflow.github.io/click.ogg id=theme-toggle role=button tabindex=0><svg class=icon><use id=theme-icon></use></svg></div></nav><main><article class=post><header class=post-header><time datetime=2025-03-29>Published on: <span class=accent-data>2025-03-29</span> </time><h1>Linear algebraic effects in Rust</h1></header><details><summary><i>Table of content</i></summary> <div class=toc-container><ul><li><a href=https://noteoverflow.github.io/posts/linear-algebraic-effect-in-rust/#the-experimental-coroutine-trait>The experimental Coroutine trait</a><li><a href=https://noteoverflow.github.io/posts/linear-algebraic-effect-in-rust/#yield-as-effects>Yield as effects</a><li><a href=https://noteoverflow.github.io/posts/linear-algebraic-effect-in-rust/#composing-effectful-programs>Composing effectful programs</a><li><a href=https://noteoverflow.github.io/posts/linear-algebraic-effect-in-rust/#epilogue>Epilogue</a></ul></div></details><div class=post-content><p>Recently I successfully implement <em>Linear Algebraic Effect(Linear AE)</em> in Rust! You may ask, what exactly is <em>Linear AE</em>? Well, honestly, the word 'linear' is used by myself to mean <em>one-shot</em>, which implies the effect cannot be cloned casually. <em>AE</em> is a special kind of structure like "exceptions can return". I'm not going to explain <em>AE</em> in detail in this post. Let's jump into rust's implementation!<h2 id=the-experimental-coroutine-trait>The experimental <code>Coroutine</code> trait</h2><p>Yes rust already has a trait called <code>Coroutine</code> whose definition is:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>pub trait </span><span>Coroutine&lt;R = ()> {
</span><span>    </span><span style=color:#b48ead>type </span><span>Yield;
</span><span>    </span><span style=color:#b48ead>type </span><span>Return;
</span><span>
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>resume</span><span>(</span><span style=color:#bf616a>self</span><span>: Pin&lt;&</span><span style=color:#b48ead>mut Self</span><span>>, </span><span style=color:#bf616a>arg</span><span>: R) -> CoroutineState&lt;</span><span style=color:#b48ead>Self::</span><span>Yield, </span><span style=color:#b48ead>Self::</span><span>Return>;
</span><span>}
</span></code></pre><p>The associated type <code>Coroutine::Yield</code> means the yielded type of the coroutine and the type <code>Coroutine::Return</code> refers to the type of returned value. For example:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>let</span><span> generator = #[</span><span style=color:#bf616a>coroutine</span><span>] || {
</span><span>    </span><span style=color:#b48ead>for</span><span> i in </span><span style=color:#d08770>0</span><span>..</span><span style=color:#d08770>10 </span><span>{
</span><span>        </span><span style=color:#2b303b;background-color:#bf616a>yield</span><span> i;
</span><span>    }
</span><span>}
</span></code></pre><p>The generated coroutine <code>generator</code> acts like a simple iterator which <em>yields</em> integers from 0 to 10. Therefore the <code>Yield</code> type of <code>generator</code> is <code>i32</code> and type <code>Return</code> is <code>()</code>.<p>Now let's focus on the method <code>Corouine::resume</code>. <code>resume</code> takes a <em>pinned self</em> since the coroutine itself may contain self-referential pointers just like those in <code>Future</code>. Every time one resume with a parameter, the coroutine returns a <code>CoroutineState</code> to indicate whether it should return or yield. For instance:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>let mut</span><span> coroutine = #[</span><span style=color:#bf616a>coroutine</span><span>] || {
</span><span>    </span><span style=color:#2b303b;background-color:#bf616a>yield</span><span> </span><span style=color:#d08770>1</span><span>;
</span><span>    "</span><span style=color:#a3be8c>foo</span><span>"
</span><span>};
</span><span>
</span><span style=color:#b48ead>match </span><span>Pin::new(&</span><span style=color:#b48ead>mut</span><span> coroutine).</span><span style=color:#96b5b4>resume</span><span>(()) {
</span><span>    CoroutineState::Yielded(</span><span style=color:#d08770>1</span><span>) => {}
</span><span>    _ => panic!("</span><span style=color:#a3be8c>unexpected return from resume</span><span>"),
</span><span>}
</span><span style=color:#b48ead>match </span><span>Pin::new(&</span><span style=color:#b48ead>mut</span><span> coroutine).</span><span style=color:#96b5b4>resume</span><span>(()) {
</span><span>    CoroutineState::Complete("</span><span style=color:#a3be8c>foo</span><span>") => {}
</span><span>    _ => panic!("</span><span style=color:#a3be8c>unexpected return from resume</span><span>"),
</span><span>}
</span></code></pre><h2 id=yield-as-effects><code>Yield</code> as effects</h2><p>Since rust's compiler can automatically transform our coroutine into a stackless state machine, we can directly utilize it's <code>Yield</code> type to implement effects!<p>Consider a common <em>logging</em> effect, let's define it as a common data strucutre:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>struct </span><span>Log(String);
</span></code></pre><p>The we can create a coroutine to yield <code>Log</code>:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>let</span><span> may_log = #[</span><span style=color:#bf616a>coroutine</span><span>] |i: </span><span style=color:#b48ead>usize</span><span>| {
</span><span>    </span><span style=color:#b48ead>if</span><span> i == </span><span style=color:#d08770>0 </span><span>{
</span><span>        </span><span style=color:#2b303b;background-color:#bf616a>yield</span><span> Log("</span><span style=color:#a3be8c>i == 0</span><span>".</span><span style=color:#96b5b4>to_string</span><span>());
</span><span>    }
</span><span>}
</span></code></pre><p>If you try to write <code>may_log</code>'s type, You will find that the <code>Yield</code> type can indicate that, while executing the coroutine, it may yield <em>logging</em>:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span>may_log: </span><span style=color:#b48ead>usize </span><span>-> () yields Log
</span></code></pre><p>Notably, <code>yield</code> is a expression which can return value which will be filled as parameters while resuming.<p>Let's abstract this pattern a little. Firstly, we can model effects as various kinds of data such as<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>enum </span><span>Effect {
</span><span>    Log(String),
</span><span>    State(State),
</span><span>    Async,
</span><span>    Injection,
</span><span>    </span><span style=color:#65737e>//...
</span><span>}
</span></code></pre><p>Then we write our program logic as a coroutine which yields its requiring effect:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span>#[</span><span style=color:#bf616a>coroutine</span><span>] |arg: I| -> R {
</span><span>    </span><span style=color:#b48ead>let</span><span> a = </span><span style=color:#2b303b;background-color:#bf616a>yield</span><span> Effect::Log("</span><span style=color:#a3be8c>a</span><span>".</span><span style=color:#96b5b4>to_string</span><span>());
</span><span>    </span><span style=color:#b48ead>let</span><span> b = </span><span style=color:#2b303b;background-color:#bf616a>yield</span><span> Effect::State(State::Get);
</span><span>    </span><span style=color:#2b303b;background-color:#bf616a>yield</span><span> Effect::State(State::Set(</span><span style=color:#d08770>0</span><span>));
</span><span>    </span><span style=color:#b48ead>let</span><span> c = </span><span style=color:#2b303b;background-color:#bf616a>yield</span><span> Effect::Async,
</span><span>    </span><span style=color:#65737e>//...
</span><span>}
</span></code></pre><p>Finally, we write a data structure to resume the coroutine until it returns.<h2 id=composing-effectful-programs>Composing effectful programs</h2><p>We can now create effectful programs. But how can we compose them? Coroutines are not like normal functions, they will not return until it yields all effects. If we write:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>let</span><span> a = </span><span style=color:#96b5b4>coroutine</span><span>(arg);
</span></code></pre><p>We are expecting <code>a</code> as the returned result of calling <code>coroutine</code>. Therefore we need to comsume all its effects:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>let</span><span> a = {
</span><span>    </span><span style=color:#b48ead>let mut</span><span> pinned = pin!(coroutine);
</span><span>    </span><span style=color:#b48ead>let mut</span><span> arg = arg;
</span><span>    </span><span style=color:#b48ead>loop </span><span>{
</span><span>        </span><span style=color:#b48ead>let</span><span> res = pinned.</span><span style=color:#96b5b4>as_mut</span><span>().</span><span style=color:#96b5b4>resume</span><span>(arg);
</span><span>        </span><span style=color:#b48ead>match</span><span> res {
</span><span>            CoroutineState::Yielded(eff) => {
</span><span>                arg = </span><span style=color:#2b303b;background-color:#bf616a>yield</span><span> eff;
</span><span>            }
</span><span>            CoroutineState::Complete(v) => </span><span style=color:#b48ead>break</span><span> v,
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>This is also a common pattern, so let's write a macro:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#96b5b4>macro_rules! </span><span>run {
</span><span>    (</span><span style=color:#bf616a>$f</span><span>:</span><span style=color:#b48ead>expr</span><span>, </span><span style=color:#bf616a>$arg</span><span>:</span><span style=color:#b48ead>expr</span><span>) => {{
</span><span>        </span><span style=color:#b48ead>let mut</span><span> pinned = pin!(</span><span style=color:#bf616a>$f</span><span>);
</span><span>        </span><span style=color:#b48ead>let mut</span><span> arg = </span><span style=color:#bf616a>$arg</span><span>;
</span><span>        </span><span style=color:#b48ead>loop </span><span>{
</span><span>            </span><span style=color:#b48ead>let</span><span> res = pinned.</span><span style=color:#96b5b4>as_mut</span><span>().</span><span style=color:#96b5b4>resume</span><span>(arg);
</span><span>            </span><span style=color:#b48ead>match</span><span> res {
</span><span>                CoroutineState::Yielded(eff) => {
</span><span>                    arg = </span><span style=color:#2b303b;background-color:#bf616a>yield</span><span> eff;
</span><span>                }
</span><span>                CoroutineState::Complete(v) => </span><span style=color:#b48ead>break</span><span> v,
</span><span>            }
</span><span>        }
</span><span>    }};
</span><span>}
</span></code></pre><p>Now we can simply write to compose effectful programs:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>let</span><span> a = run!(coroutine, arg);
</span></code></pre><h2 id=epilogue>Epilogue</h2><p>This a demo implementation of algebraic effect in Rust. There is a better version with <em>Handlers</em> in <a href=https://crates.io/crates/algoroutine>crates.io/algoroutine</a>.</div><div class=post-tags><a class=tag href=/tags/rust>#rust </a><a class=tag href=/tags/programming>#programming </a><a class=tag href=/tags/effect-system>#effect-system </a></div></article></main><footer><hr><div id=footer-container><i><a href=/test>Q.E.D.</a></i></div><br></footer><script defer src=https://noteoverflow.github.io/js/script.js></script>