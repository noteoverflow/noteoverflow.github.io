<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="index, follow" name=robots><link href=https://noteoverflow.github.io/rss.xml rel=alternate title=RSS type=application/rss+xml><title>noteoverflow | Another view of Rust's lifetime II - The algorithm</title><link as=style href=https://noteoverflow.github.io/css/style.css rel=preload><link crossorigin href=https://noteoverflow.github.io/css/reset-min.css rel=stylesheet><link crossorigin href=https://noteoverflow.github.io/css/suCSS-min.css rel=stylesheet><link href=https://noteoverflow.github.io/css/style.css rel=stylesheet><link href=https://noteoverflow.github.io/css/custom.css rel=stylesheet><link href=https://noteoverflow.github.io/img/favicon.ico rel=icon><link href=https://noteoverflow.github.io/css/katex.min.css rel=stylesheet><script defer src=https://noteoverflow.github.io/js/katex.min.js></script><script defer src=https://noteoverflow.github.io/js/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded", function() {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: "$$", right: "$$", display: true},
                        {left: "$", right: "$", display: false},
                    ]
                });
            });</script><body><nav id=nav-bar><a href=/> [post] </a><a href=/pinned> [pinned] </a><a href=/tags> [tag] </a><a href=/about> [about] </a> Â  <div aria-label="Toggle theme" class=theme-toggle data-icon-base=https://noteoverflow.github.io/icons.svg data-icon-dark=#darkMode data-icon-light=#lightMode data-sound-src=https://noteoverflow.github.io/click.ogg id=theme-toggle role=button tabindex=0><svg class=icon><use id=theme-icon></use></svg></div></nav><main><article class=post><header class=post-header><time datetime=2025-06-01>Published on: <span class=accent-data>2025-06-01</span> </time><h1>Another view of Rust's lifetime II - The algorithm</h1></header><details><summary><i>Table of content</i></summary> <div class=toc-container><ul><li><a href=https://noteoverflow.github.io/posts/another-view-of-rust-s-lifetime-ii-the-algorithm/#meta-language>Meta-language</a> <ul><li><a href=https://noteoverflow.github.io/posts/another-view-of-rust-s-lifetime-ii-the-algorithm/#atomic-entity>Atomic entity</a><li><a href=https://noteoverflow.github.io/posts/another-view-of-rust-s-lifetime-ii-the-algorithm/#derived-entity>Derived entity</a></ul><li><a href=https://noteoverflow.github.io/posts/another-view-of-rust-s-lifetime-ii-the-algorithm/#materials>Materials</a> <ul><li><a href=https://noteoverflow.github.io/posts/another-view-of-rust-s-lifetime-ii-the-algorithm/#g-the-cfg>$G$ the CFG</a><li><a href=https://noteoverflow.github.io/posts/another-view-of-rust-s-lifetime-ii-the-algorithm/#r-the-regions>$R$ the Regions</a><li><a href=https://noteoverflow.github.io/posts/another-view-of-rust-s-lifetime-ii-the-algorithm/#l-the-loans>$L$ the Loans</a></ul><li><a href=https://noteoverflow.github.io/posts/another-view-of-rust-s-lifetime-ii-the-algorithm/#relations>Relations</a> <ul><li><a href=https://noteoverflow.github.io/posts/another-view-of-rust-s-lifetime-ii-the-algorithm/#injection>Injection</a><li><a href=https://noteoverflow.github.io/posts/another-view-of-rust-s-lifetime-ii-the-algorithm/#liveness>Liveness</a><li><a href=https://noteoverflow.github.io/posts/another-view-of-rust-s-lifetime-ii-the-algorithm/#requirement>Requirement</a><li><a href=https://noteoverflow.github.io/posts/another-view-of-rust-s-lifetime-ii-the-algorithm/#invalidation>Invalidation</a><li><a href=https://noteoverflow.github.io/posts/another-view-of-rust-s-lifetime-ii-the-algorithm/#errors>Errors</a></ul><li><a href=https://noteoverflow.github.io/posts/another-view-of-rust-s-lifetime-ii-the-algorithm/#refinement>Refinement</a> <ul><li><a href=https://noteoverflow.github.io/posts/another-view-of-rust-s-lifetime-ii-the-algorithm/#reassignment>Reassignment</a><li><a href=https://noteoverflow.github.io/posts/another-view-of-rust-s-lifetime-ii-the-algorithm/#reborrow>Reborrow</a></ul></ul></div></details><div class=post-content><p>Previously, I described another view of Rust's lifetime which is dual to the traditional one in<blockquote><p><a href=/posts/another-view-of-rusts-lifetime>Another view of Rust's lifetime</a></blockquote><p>Today, let's try to make it a concrete algorithm demo based on <a href=https://rust-lang.github.io/polonius/>Polonius</a>. To formally and clearly describe the core rules of the algorithm, I want to use a special DSL which is drived from Datalog:<h2 id=meta-language>Meta-language</h2><p>The lanugage we use to describe rules has only 2 basic components:<h3 id=atomic-entity>Atomic entity</h3><p>If a entity derives itself, we call it atomic entity (usually they are the input of the algorithm). For instance:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>reachable (a : A) (b : B)
</span></code></pre><p>We can also view this entity as a type:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>reachable : A -> B -> Input
</span></code></pre><p>We use a spectial kind <code>Input</code> to imply that the entity is atomic.<h3 id=derived-entity>Derived entity</h3><p>This kind of entities can be derived from others (even recursively!):<pre style=color:#c0c5ce;background-color:#2b303b><code><span>path : P -> P -> Type
</span><span>
</span><span>trans : path a b -> path b c -> path a c
</span></code></pre><p>Here <code>trans</code> serves as a deriving rule.<h2 id=materials>Materials</h2><p>Before demonstrating the whole algorithm, we firstly prepare some materials to cook.<h3 id=g-the-cfg>$G$ the CFG</h3><p>As in the traditional algorithm, we need the Control Flow Graph(CFG), denoted $G$, to help us trace program and memory flow.<p>The CFG comprises set of MIR Point, denoted $P$ and control flow edges between points $E$. To get the source and destination of one edge, we have two functions:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>source : E -> P
</span><span>dest : E -> P
</span></code></pre><p>Since we are working on the meta-language, we say edge <code>e</code> exists by:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>edge : (source e) -> (dest e) -> Input
</span></code></pre><p>Normally, we denote one edge as <code>edge a b</code> by its end points.<h3 id=r-the-regions>$R$ the Regions</h3><p>Region is the core concept of the borrow checker. Then what do we mean by a <strong>region</strong>? Let's consider how to assemble references and memory locations in Rust! Basically, we use product type, or, if you like, <code>struct</code>s:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>struct </span><span>Region&lt;</span><span style=color:#b48ead>'a</span><span>, </span><span style=color:#b48ead>'b</span><span>> {
</span><span>    </span><span style=color:#bf616a>a</span><span>: &</span><span style=color:#b48ead>'a</span><span> A,
</span><span>    </span><span style=color:#bf616a>b</span><span>: &</span><span style=color:#b48ead>'b</span><span> B,
</span><span>}
</span></code></pre><p>Similarly, We just define regions as products of references. However, as we want to be more specific here, we call referred references <strong>loans</strong>:<blockquote><p>Regions are sets of loans.</blockquote><p>Moreover, since regions can be viewed as sets, we then have subset relations which is explored in the next section.<h3 id=l-the-loans>$L$ the Loans</h3><p>In the previous part, we used loans to define regions. Loans can be viewed as any borrow sites.<p>For example:<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>let</span><span> x = vec![</span><span style=color:#d08770>1</span><span>, </span><span style=color:#d08770>2</span><span>];
</span><span>
</span><span style=color:#b48ead>let</span><span> p: &</span><span style=color:#b48ead>'a i32 </span><span>= </span><span style=color:#b48ead>if </span><span style=color:#96b5b4>random</span><span>() {
</span><span>    &x[</span><span style=color:#d08770>0</span><span>] </span><span style=color:#65737e>// Loan L0
</span><span>} </span><span style=color:#b48ead>else </span><span>{
</span><span>    &x[</span><span style=color:#d08770>1</span><span>] </span><span style=color:#65737e>// Loan L1
</span><span>};
</span></code></pre><p>Here, the region 'a would correspond to the set {L0, L1}, since it may refer to data produced by the loan L0, but it may also refer to data from the loan L1.<h2 id=relations>Relations</h2><h3 id=injection>Injection</h3><p>We mentioned that regions can form subset relations. But we can say more general here by defining relation structures between regions at the same point.<pre style=color:#c0c5ce;background-color:#2b303b><code><span>in : P -> R -> R -> Type
</span></code></pre><p>To simplify the notation a little, we denote <code>a in b at p</code> just as <code>in p a b</code>.<pre style=color:#c0c5ce;background-color:#2b303b><code><span>trans       : a in b at p -> b in c at p -> a in c at p
</span><span>follow_edge : a in b at p -> edge p q -> a in b at q
</span></code></pre><p>Also, we have some input injection relations:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>base_in : P -> R -> R -> Input
</span></code></pre><p>and one more rule:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>atom : base_in p a b -> a in b at p
</span></code></pre><h3 id=liveness>Liveness</h3><p>a region <code>'a</code> is live at some point P if some reference with type <code>&'a i32</code> may be dereferenced later:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>region_live_at : R -> P -> Input
</span></code></pre><p>We also talk about liveness of loans:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>loan_live_at : L -> P -> Type
</span><span>
</span><span>derive_loan_live : region_live_at r p -> require r l p -> loan_live_at l p
</span></code></pre><p>What's <code>require</code> here?<h3 id=requirement>Requirement</h3><p><code>require R L P</code> means:<blockquote><p>If the terms of the loan L are violated at the point P, then the region R is invalidated.</blockquote><p>Formally:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>require : R -> L -> P -> Type
</span></code></pre><p>and rules:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>from_loan     : loan r l p -> require r l p
</span><span>follow_subset : require r' l p -> r' in r at p -> require r l p
</span><span>follow_cfg    : require r l p -> edge p q -> require r l q
</span></code></pre><h3 id=invalidation>Invalidation</h3><p>And now finally we can define what a borrow check error is. Before that, We need to define an input invalidates(P, L), which indicates that some access or action at the point P invalidates the terms of the loan L:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>invalidate : P -> L -> Input
</span></code></pre><h3 id=errors>Errors</h3><p>Finally<pre style=color:#c0c5ce;background-color:#2b303b><code><span>error : P -> Type
</span><span>
</span><span>detect_error : exists l. invalidate p l -> loan_live_at l p -> error p 
</span></code></pre><h2 id=refinement>Refinement</h2><p>The core algorithm is rather coarse. We need refinements to handle reassignment and reborrow problems.<h3 id=reassignment>Reassignment</h3><h3 id=reborrow>Reborrow</h3></div><div class=post-tags><a class=tag href=/tags/rust>#rust </a><a class=tag href=/tags/programming>#programming </a></div></article></main><footer><hr><div id=footer-container><i><a href=/test>Q.E.D.</a></i></div><br></footer><script defer src=https://noteoverflow.github.io/js/script.js></script>