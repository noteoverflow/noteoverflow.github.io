<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="index, follow" name=robots><link href=https://noteoverflow.github.io/rss.xml rel=alternate title=RSS type=application/rss+xml><title>noteoverflow | Relaxed ordering and visibility</title><link as=style href=https://noteoverflow.github.io/css/style.css rel=preload><link crossorigin href=https://noteoverflow.github.io/css/reset-min.css rel=stylesheet><link crossorigin href=https://noteoverflow.github.io/css/suCSS-min.css rel=stylesheet><link href=https://noteoverflow.github.io/css/style.css rel=stylesheet><link href=https://noteoverflow.github.io/css/custom.css rel=stylesheet><link href=https://noteoverflow.github.io/img/favicon.ico rel=icon><body><nav id=nav-bar><a href=/> [post] </a><a href=/pinned> [pinned] </a><a href=/tags> [tag] </a><a href=/about> [about] </a> Â  <div aria-label="Toggle theme" class=theme-toggle data-icon-base=https://noteoverflow.github.io/icons.svg data-icon-dark=#darkMode data-icon-light=#lightMode data-sound-src=https://noteoverflow.github.io/click.ogg id=theme-toggle role=button tabindex=0><svg class=icon><use id=theme-icon></use></svg></div></nav><main><article class=post><header class=post-header><time datetime=2024-08-05>Published on: <span class=accent-data>2024-08-05</span> </time><h1>Relaxed ordering and visibility</h1></header><div class=post-content><p>I'm really curious that whether the <em>relaxed</em> memory ordering can ensure to see the last recent value in the total modification order. It appears that the C++ memory model alone is not enough.<p>The C++ memory model only states that<blockquote><p>Implementations should make atomic stores visible to atomic loads within a reasonable amount of time.</blockquote><p>which means in the code<pre class=language-c++ data-lang=c++ style=color:#c0c5ce;background-color:#2b303b><code class=language-c++ data-lang=c++><span>std::atomic&lt;</span><span style=color:#b48ead>int</span><span>> </span><span style=color:#bf616a>g</span><span>{</span><span style=color:#d08770>0</span><span>};
</span><span>
</span><span style=color:#65737e>// thread 1
</span><span>g.</span><span style=color:#bf616a>store</span><span>(</span><span style=color:#d08770>42</span><span>);
</span><span>
</span><span style=color:#65737e>// thread 2
</span><span style=color:#b48ead>int</span><span> a = g.</span><span style=color:#bf616a>load</span><span>();
</span><span style=color:#65737e>// do stuff with a
</span><span style=color:#b48ead>int</span><span> b = g.</span><span style=color:#bf616a>load</span><span>();
</span></code></pre><p>if thread 1 has executed the storing, thread 2 is not guaranteed to load 42 immediately.<p>However, C++ standard does ensure the visibility of <strong>RMW(Read-Modify-Write)</strong> operations as the standard says:<blockquote><p>Atomic read-modify-write operations shall always read the last value (in the modification order) written before the write associated with the read-modify-write operation.</blockquote><p>which means you don't need to worry about operations like <code>fetch_xx</code> and <code>compare_exchange</code>.</div><div class=post-tags><a class=tag href=/tags/programming>#programming </a><a class=tag href=/tags/cpp>#cpp </a></div></article></main><footer><hr><div id=footer-container><i><a href=/test>Q.E.D.</a></i></div><br></footer><script defer src=https://noteoverflow.github.io/js/script.js></script>