<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="index, follow" name=robots><link href=https://noteoverflow.github.io/rss.xml rel=alternate title=RSS type=application/rss+xml><title>noteoverflow | Relaxed ordering and visibility</title><link as=style href=https://noteoverflow.github.io/css/style.css rel=preload><link crossorigin href=https://noteoverflow.github.io/css/reset-min.css rel=stylesheet><link crossorigin href=https://noteoverflow.github.io/css/suCSS-min.css rel=stylesheet><link href=https://noteoverflow.github.io/css/style.css rel=stylesheet><link href=https://noteoverflow.github.io/css/custom.css rel=stylesheet><link href=https://noteoverflow.github.io/img/favicon.ico rel=icon><body><nav id=nav-bar><a href=/posts> [post] </a><a href=/pinned> [pin] </a><a href=/tags> [tag] </a><a href=/> [self] </a> Â  <div aria-label="Toggle theme" class=theme-toggle data-icon-base=https://noteoverflow.github.io/icons.svg data-icon-dark=#darkMode data-icon-light=#lightMode data-sound-src=https://noteoverflow.github.io/click.ogg id=theme-toggle role=button tabindex=0><svg class=icon><use id=theme-icon></use></svg></div></nav><main><article class=post><header class=post-header><time datetime=2024-08-05>Published on: <span class=accent-data>2024-08-05</span> </time><div class=post-tags><a class=tag href=/tags/programming>#programming </a><a class=tag href=/tags/cpp>#cpp </a></div><h1>Relaxed ordering and visibility</h1></header><div class=post-content><p>I'm really curious that whether the <em>relaxed</em> memory ordering can ensure to see the last recent value in the total modification order. It appears that the C++ memory model alone is not enough.<p>The C++ memory model only states that<blockquote><p>Implementations should make atomic stores visible to atomic loads within a reasonable amount of time.</blockquote><p>which means in the code<pre class=language-c++ data-lang=c++ style=color:#ccc9c2;background-color:#212733><code class=language-c++ data-lang=c++><span>std</span><span style=color:#f29e74>::</span><span>atomic&lt;</span><span style=color:#ffa759>int</span><span>> </span><span style=color:#ffd580>g</span><span>{</span><span style=color:#fc6>0</span><span>}</span><span style=color:#ccc9c2cc>;
</span><span>
</span><span style=color:#5c6773;font-style:italic>// thread 1
</span><span>g</span><span style=color:#f29e74>.</span><span style=color:#ffd580>store</span><span>(</span><span style=color:#fc6>42</span><span>)</span><span style=color:#ccc9c2cc>;
</span><span>
</span><span style=color:#5c6773;font-style:italic>// thread 2
</span><span style=color:#ffa759>int</span><span> a </span><span style=color:#f29e74>=</span><span> g</span><span style=color:#f29e74>.</span><span style=color:#ffd580>load</span><span>()</span><span style=color:#ccc9c2cc>;
</span><span style=color:#5c6773;font-style:italic>// do stuff with a
</span><span style=color:#ffa759>int</span><span> b </span><span style=color:#f29e74>=</span><span> g</span><span style=color:#f29e74>.</span><span style=color:#ffd580>load</span><span>()</span><span style=color:#ccc9c2cc>;
</span></code></pre><p>if thread 1 has executed the storing, thread 2 is not guaranteed to load 42 immediately.<p>However, C++ standard does ensure the visibility of <strong>RMW(Read-Modify-Write)</strong> operations as the standard says:<blockquote><p>Atomic read-modify-write operations shall always read the last value (in the modification order) written before the write associated with the read-modify-write operation.</blockquote><p>which means you don't need to worry about operations like <code>fetch_xx</code> and <code>compare_exchange</code>.</div></article></main><footer><br><div id=footer-container><i><a href=/internal/test>Q.E.D.</a></i></div><br></footer><script defer src=https://noteoverflow.github.io/js/script.js></script><div class=comments></div>