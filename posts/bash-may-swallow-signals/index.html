<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="index, follow" name=robots><link href=https://noteoverflow.github.io/rss.xml rel=alternate title=RSS type=application/rss+xml><title>noteoverflow | Bash may swallow signals</title><link as=style href=https://noteoverflow.github.io/css/style.css rel=preload><link crossorigin href=https://noteoverflow.github.io/css/reset-min.css rel=stylesheet><link crossorigin href=https://noteoverflow.github.io/css/suCSS-min.css rel=stylesheet><link href=https://noteoverflow.github.io/css/style.css rel=stylesheet><link href=https://noteoverflow.github.io/css/custom.css rel=stylesheet><link href=https://noteoverflow.github.io/img/favicon.ico rel=icon><body><nav id=nav-bar><a href=/posts> [post] </a><a href=/pinned> [pin] </a><a href=/tags> [tag] </a><a href=/> [self] </a> Â  <div aria-label="Toggle theme" class=theme-toggle data-icon-base=https://noteoverflow.github.io/icons.svg data-icon-dark=#darkMode data-icon-light=#lightMode data-sound-src=https://noteoverflow.github.io/click.ogg id=theme-toggle role=button tabindex=0><svg class=icon><use id=theme-icon></use></svg></div></nav><main><article class=post><header class=post-header><time datetime=2024-10-26>Published on: <span class=accent-data>2024-10-26</span> </time><div class=post-tags><a class=tag href=/tags/programming>#programming </a></div><h1>Bash may swallow signals</h1></header><div class=post-content><p>Recently I encountered a confusing bug:<blockquote><p>A simple <code>eprintln!</code> in Rust may cause panic!</blockquote><p>That sounds weird, right? Let's check the <code>eprintln!</code>'s doc:<blockquote><p>Prints to the standard error, with a newline.<p>Equivalent to the <a href=crate::println><code>println!</code></a> macro, except that output goes to <a href=crate::io::stderr><code>io::stderr</code></a> instead of <a href=crate::io::stdout><code>io::stdout</code></a>. See <a href=crate::println><code>println!</code></a> for example usage.<p>Use <code>eprintln!</code> only for error and progress messages. Use <code>println!</code> instead for the primary output of your program.<p>See <a href=../std/fmt/index.html>the formatting documentation in <code>std::fmt</code></a> for details of the macro argument syntax.<h1 id=panics>Panics</h1><p>Panics if writing to <code>io::stderr</code> fails.<p>Writing to non-blocking stderr can cause an error, which will lead this macro to panic.<h1 id=examples>Examples</h1><pre style=color:#ccc9c2;background-color:#212733><code><span>eprintln!("Error: Could not complete task");
</span></code></pre></blockquote><p>Therefore, at least we can conclude that print will only panic when the stderr cannot be written, but how?<h2 id=redirected-stderr>Redirected stderr</h2><p>I checked the original stderr and It's normal. But quickly I noticed that the rust program's stderr was been redirected to another process's input.<p>Now the problem seems to be clear:<blockquote><p>The process which redireced Rust's program's stderr exits, then <code>eprintln!</code> writes to broken pipe and panic!</blockquote><p>But why? Why still write to stderr when something is broken?<h2 id=bash-launched-bash>Bash launched bash</h2><p>I noticed that the launch shell did not directly <code>exec</code> Rust program. In stead, it call bash on another bash script which <code>exec</code> the real program. For a minimal example:<pre class=language-sh data-lang=sh style=color:#ccc9c2;background-color:#212733><code class=language-sh data-lang=sh><span style=color:#5c6773;font-style:italic># launch.sh
</span><span style=color:#ffd580>bash</span><span> run.sh
</span><span>
</span><span style=color:#5c6773;font-style:italic># run.sh
</span><span style=color:#f28779>exec</span><span> program
</span></code></pre><p>When we run the <code>launch.sh</code>:<pre class=language-sh data-lang=sh style=color:#ccc9c2;background-color:#212733><code class=language-sh data-lang=sh><span style=color:#ffd580>bash</span><span> launch.sh
</span></code></pre><p>We create 2 processed: <code>bash lanuch.sh</code> and <code>program</code>.<p>It seems still fine. But if you try to <code>kill</code> the bash process, you can observe that, although the <code>bash</code> process is killed, the <code>program</code> process is still alive!<blockquote><p>BASH SWALLOWS SIGNALS!</blockquote><p>Now we completely unravel the reason:<blockquote><p>When the pod try to exit and kill process, it failed to kill the real process and leave it writing to broken pipes which leads to panic and coredumps.</blockquote></div></article></main><footer><br><div id=footer-container><i><a href=/internal/test>Q.E.D.</a></i></div><br></footer><script defer src=https://noteoverflow.github.io/js/script.js></script><div class=comments></div>