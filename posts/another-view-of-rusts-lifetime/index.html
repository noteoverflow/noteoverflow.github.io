<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="index, follow" name=robots><link href=https://noteoverflow.github.io/rss.xml rel=alternate title=RSS type=application/rss+xml><title>noteoverflow | Another view of Rust's lifetime</title><link as=style href=https://noteoverflow.github.io/css/style.css rel=preload><link crossorigin href=https://noteoverflow.github.io/css/reset-min.css rel=stylesheet><link crossorigin href=https://noteoverflow.github.io/css/suCSS-min.css rel=stylesheet><link href=https://noteoverflow.github.io/css/style.css rel=stylesheet><link href=https://noteoverflow.github.io/css/custom.css rel=stylesheet><link href=https://noteoverflow.github.io/img/favicon.ico rel=icon><body><nav id=nav-bar><a href=/posts> [post] </a><a href=/pinned> [pin] </a><a href=/tags> [tag] </a><a href=/> [self] </a>   <div aria-label="Toggle theme" class=theme-toggle data-icon-base=https://noteoverflow.github.io/icons.svg data-icon-dark=#darkMode data-icon-light=#lightMode data-sound-src=https://noteoverflow.github.io/click.ogg id=theme-toggle role=button tabindex=0><svg class=icon><use id=theme-icon></use></svg></div></nav><main><article class=post><header class=post-header><time datetime=2024-08-11>Published on: <span class=accent-data>2024-08-11</span> </time><div class=post-tags><a class=tag href=/tags/rust>#rust </a><a class=tag href=/tags/programming>#programming </a></div><h1>Another view of Rust's lifetime</h1></header><details><summary><i>Table of content</i></summary> <div class=toc-container><ul><li><a href=https://noteoverflow.github.io/posts/another-view-of-rusts-lifetime/#lifetime-as-scope>Lifetime as scope?</a><li><a href=https://noteoverflow.github.io/posts/another-view-of-rusts-lifetime/#lifetime-as-regions-of-code>Lifetime as regions of code?</a><li><a href=https://noteoverflow.github.io/posts/another-view-of-rusts-lifetime/#lifetime-subtyping>Lifetime subtyping</a><li><a href=https://noteoverflow.github.io/posts/another-view-of-rusts-lifetime/#lifetime-as-memory-references>Lifetime as memory references</a></ul></div></details><div class=post-content><p>Compared with <em>Haskell</em>, Rust is different for its effect system and ownership system. Inside ownership system, lifetime plays an important role on borrowing and safety. Traditionally, people think about lifetime as some region of code, which is a little kind of vague. Why not try to see lifetime as a kind of memory(dependency) reference?<h2 id=lifetime-as-scope>Lifetime as scope?</h2><p><em>The Rust book</em> suggests viewing lifetime as scopes. Consider a simple example:<pre class=language-rust data-lang=rust style=color:#ccc9c2;background-color:#212733><code class=language-rust data-lang=rust><span style=color:#ffa759>fn </span><span style=color:#ffd580>main</span><span>() {
</span><span>    </span><span style=color:#ffa759>let</span><span> r</span><span style=color:#ccc9c2cc>;                </span><span style=color:#5c6773;font-style:italic>// ---------+-- 'a
</span><span>                          </span><span style=color:#5c6773;font-style:italic>//          |
</span><span>    {                     </span><span style=color:#5c6773;font-style:italic>//          |
</span><span>        </span><span style=color:#ffa759>let</span><span> x </span><span style=color:#f29e74>= </span><span style=color:#fc6>5</span><span style=color:#ccc9c2cc>;        </span><span style=color:#5c6773;font-style:italic>// -+-- 'b  |
</span><span>        r </span><span style=color:#f29e74>= &</span><span>x</span><span style=color:#ccc9c2cc>;           </span><span style=color:#5c6773;font-style:italic>//  |       |
</span><span>    }                     </span><span style=color:#5c6773;font-style:italic>// -+       |
</span><span>                          </span><span style=color:#5c6773;font-style:italic>//          |
</span><span>    </span><span style=color:#f28779>println!</span><span>(</span><span style=color:#bae67e>"r: </span><span style=color:#fc6>{r}</span><span style=color:#bae67e>"</span><span>)</span><span style=color:#ccc9c2cc>;   </span><span style=color:#5c6773;font-style:italic>//          |
</span><span>}                         </span><span style=color:#5c6773;font-style:italic>// ---------+
</span></code></pre><p>Since <code>x</code>'s lifetime <code>'b</code> is shorter than <code>r</code>'s <code>'a</code>, we cannot assign <code>&x</code> to <code>r</code>. However, this reason is rather imprecise. If we simply remove the last <code>println!</code> line, this code just compile fine.:<pre class=language-rust data-lang=rust style=color:#ccc9c2;background-color:#212733><code class=language-rust data-lang=rust><span style=color:#ffa759>fn </span><span style=color:#ffd580>main</span><span>() {
</span><span>    </span><span style=color:#ffa759>let</span><span> r</span><span style=color:#ccc9c2cc>;                </span><span style=color:#5c6773;font-style:italic>// ---------+-- 'a
</span><span>                          </span><span style=color:#5c6773;font-style:italic>//          |
</span><span>    {                     </span><span style=color:#5c6773;font-style:italic>//          |
</span><span>        </span><span style=color:#ffa759>let</span><span> x </span><span style=color:#f29e74>= </span><span style=color:#fc6>5</span><span style=color:#ccc9c2cc>;        </span><span style=color:#5c6773;font-style:italic>// -+-- 'b  |
</span><span>        r </span><span style=color:#f29e74>= &</span><span>x</span><span style=color:#ccc9c2cc>;           </span><span style=color:#5c6773;font-style:italic>//  |       |
</span><span>    }                     </span><span style=color:#5c6773;font-style:italic>// -+       |
</span><span>}                         </span><span style=color:#5c6773;font-style:italic>// ---------+
</span></code></pre><p>Why?<p>Even worse, lifetime can contain <em>holes</em>, where it’s intermittently invalid between where it starts and where it ultimately ends. For example, let's change our previous code simply:<pre class=language-rust data-lang=rust style=color:#ccc9c2;background-color:#212733><code class=language-rust data-lang=rust><span style=color:#ffa759>fn </span><span style=color:#ffd580>main</span><span>() {
</span><span>    </span><span style=color:#ffa759>let</span><span> i </span><span style=color:#f29e74>= </span><span style=color:#fc6>42</span><span style=color:#ccc9c2cc>;
</span><span>    </span><span style=color:#ffa759>let mut</span><span> r</span><span style=color:#ccc9c2cc>;                
</span><span>    {
</span><span>        </span><span style=color:#ffa759>let</span><span> x </span><span style=color:#f29e74>= </span><span style=color:#fc6>5</span><span style=color:#ccc9c2cc>;        
</span><span>        r </span><span style=color:#f29e74>= &</span><span>x</span><span style=color:#ccc9c2cc>;            </span><span style=color:#5c6773;font-style:italic>// -------------+-- 'r
</span><span>                           </span><span style=color:#5c6773;font-style:italic>//              |
</span><span>    }                      </span><span style=color:#5c6773;font-style:italic>// -------------+
</span><span>
</span><span>    r </span><span style=color:#f29e74>= &</span><span>i</span><span style=color:#ccc9c2cc>;                </span><span style=color:#5c6773;font-style:italic>// -------------+-- 'r
</span><span>    </span><span style=color:#f28779>println!</span><span>(</span><span style=color:#bae67e>"r: </span><span style=color:#fc6>{}</span><span style=color:#bae67e>"</span><span style=color:#ccc9c2cc>, </span><span style=color:#f29e74>*</span><span>r)</span><span style=color:#ccc9c2cc>; </span><span style=color:#5c6773;font-style:italic>//              |
</span><span>}                          </span><span style=color:#5c6773;font-style:italic>// -------------+
</span></code></pre><p>This time the code compiles. Surprise! Why? why this code compiles fine?? If r's lifetime coprresponds to <code>x</code>'s reference, why <code>r</code> can br printed outside <code>x</code>'s scope now? There may exist holes in lifetime.<p>Apparently <em>scope</em> view is not correct. We need something better.<h2 id=lifetime-as-regions-of-code>Lifetime as regions of code?</h2><p><em>Rustonomicon</em> the book suggests viewing lifetime as named regions of code. Now our previous problems are solved, since <code>'r</code> spans only its valid data flow regions and the regions can contains arbitrary holes.<blockquote><p>Lifetime is named regions of code where the pointed data is valid.</blockquote><p>What about lifetime constraints like <code>'a: 'b</code>?<h2 id=lifetime-subtyping>Lifetime subtyping</h2><p>Subtyping is really just a spectial relation just as other <em>trait</em>s can represent. The only subtyping in rust is lifetime subtyping.<blockquote><p>if <code>'b</code> outlives <code>'a</code>, then <code>'b: 'a</code> and <code>&'b T</code> is a subtype of <code>&'a T</code>.</blockquote><p>Since <code>&'b T</code> is a subtype of <code>&'a T</code>, we can assign any <code>&'b T</code> to <code>&'a T</code>. For example(again from <em>the rust book</em>):<pre class=language-rust data-lang=rust style=color:#ccc9c2;background-color:#212733><code class=language-rust data-lang=rust><span style=color:#ffa759>fn </span><span style=color:#ffd580>longer</span><span>&lt;</span><span style=color:#ffa759>'a</span><span>>(</span><span style=color:#fc6>s1</span><span style=color:#ccc9c2cc>: </span><span style=color:#f29e74>&</span><span style=color:#ffa759>'a str</span><span>, </span><span style=color:#fc6>s2</span><span style=color:#ccc9c2cc>: </span><span style=color:#f29e74>&</span><span style=color:#ffa759>'a str</span><span>) </span><span style=color:#ccc9c2cc>-> </span><span style=color:#f29e74>&</span><span style=color:#ffa759>'a str </span><span>{
</span><span>    </span><span style=color:#ffa759>if</span><span> s1</span><span style=color:#f29e74>.</span><span style=color:#f28779>len</span><span>() </span><span style=color:#f29e74>></span><span> s2</span><span style=color:#f29e74>.</span><span style=color:#f28779>len</span><span>() {
</span><span>        s1
</span><span>    } </span><span style=color:#ffa759>else </span><span>{
</span><span>        s2
</span><span>    }
</span><span>}
</span></code></pre><p>Actually, this code cannot compile without lifetime subtyping. It's equivalent to this code:<pre class=language-rust data-lang=rust style=color:#ccc9c2;background-color:#212733><code class=language-rust data-lang=rust><span style=color:#ffa759>fn </span><span style=color:#ffd580>longer</span><span>&lt;</span><span style=color:#ffa759>'a</span><span>, </span><span style=color:#ffa759>'b</span><span>, </span><span style=color:#ffa759>'c</span><span>>(</span><span style=color:#fc6>s1</span><span style=color:#ccc9c2cc>: </span><span style=color:#f29e74>&</span><span style=color:#ffa759>'a str</span><span>, </span><span style=color:#fc6>s2</span><span style=color:#ccc9c2cc>: </span><span style=color:#f29e74>&</span><span style=color:#ffa759>'b str</span><span>) </span><span style=color:#ccc9c2cc>-> </span><span style=color:#f29e74>&</span><span style=color:#ffa759>'c str 
</span><span style=color:#ffa759>where
</span><span>    </span><span style=color:#ffa759>'a</span><span style=color:#ccc9c2cc>: </span><span style=color:#ffa759>'c</span><span>,
</span><span>    </span><span style=color:#ffa759>'b</span><span style=color:#ccc9c2cc>: </span><span style=color:#ffa759>'c</span><span>,
</span><span>{
</span><span>    </span><span style=color:#ffa759>if</span><span> s1</span><span style=color:#f29e74>.</span><span style=color:#f28779>len</span><span>() </span><span style=color:#f29e74>></span><span> s2</span><span style=color:#f29e74>.</span><span style=color:#f28779>len</span><span>() {
</span><span>        s1
</span><span>    } </span><span style=color:#ffa759>else </span><span>{
</span><span>        s2
</span><span>    }
</span><span>}
</span></code></pre><p>Automatic subtyping is only a fancy and convenient way to expression this relationship.<h2 id=lifetime-as-memory-references>Lifetime as memory references</h2><p>If you know <em>category theory</em>, you may heard of <em>duality</em>. Just like <em>category theory</em>, the code region view also has its <em>DUAL</em> view:<blockquote><p>A lifetime refers to some memory or other resources and constraint <code>'a: 'b</code> can also be read <code>'a</code> refers to a subset of <code>'b</code> or, if you like, <code>'a</code> in <code>'b</code>.</blockquote><p>In this dual view, if <code>'a</code> outlives <code>'b</code>, <code>'b</code> contains more resources than <code>'a</code> does. I find this view is somehow complement to the region view.<p>Let's demonstrate this view with the following code:<pre class=language-rust data-lang=rust style=color:#ccc9c2;background-color:#212733><code class=language-rust data-lang=rust><span style=color:#ffa759>fn </span><span style=color:#ffd580>use_longer</span><span>() {
</span><span>    </span><span style=color:#ffa759>let</span><span> a</span><span style=color:#ccc9c2cc>: </span><span style=color:#f29e74>&</span><span style=color:#ffa759>str </span><span style=color:#f29e74>= </span><span style=color:#bae67e>"a"</span><span style=color:#ccc9c2cc>;     </span><span style=color:#5c6773;font-style:italic>// 'a
</span><span>    </span><span style=color:#ffa759>let</span><span> b</span><span style=color:#ccc9c2cc>: </span><span style=color:#f29e74>&</span><span style=color:#ffa759>str </span><span style=color:#f29e74>= </span><span style=color:#bae67e>"b"</span><span style=color:#ccc9c2cc>;     </span><span style=color:#5c6773;font-style:italic>// 'b
</span><span>    </span><span style=color:#ffa759>let</span><span> c</span><span style=color:#ccc9c2cc>: </span><span style=color:#f29e74>&</span><span style=color:#ffa759>str </span><span style=color:#f29e74>= </span><span style=color:#bae67e>"c"</span><span style=color:#ccc9c2cc>;     </span><span style=color:#5c6773;font-style:italic>// 'c
</span><span>
</span><span>    </span><span style=color:#ffa759>let</span><span> d </span><span style=color:#f29e74>= </span><span style=color:#f28779>longer</span><span>(a</span><span style=color:#ccc9c2cc>,</span><span> b)</span><span style=color:#ccc9c2cc>;  </span><span style=color:#5c6773;font-style:italic>// 'd
</span><span>    </span><span style=color:#ffa759>let</span><span> d </span><span style=color:#f29e74>= </span><span style=color:#f28779>longer</span><span>(c</span><span style=color:#ccc9c2cc>,</span><span> d)</span><span style=color:#ccc9c2cc>;  </span><span style=color:#5c6773;font-style:italic>// 'e
</span><span>}
</span></code></pre><pre style=color:#ccc9c2;background-color:#212733><code><span>'e -> {
</span><span>    'd -> {
</span><span>        'a,
</span><span>        'b,
</span><span>    },
</span><span>    'c,
</span><span>}
</span></code></pre><p>where arrow <code>-></code> means point to some resource and <code>{}</code> means union. From this graph, we can easily conclude:<pre style=color:#ccc9c2;background-color:#212733><code><span>'a: 'd
</span><span>'b: 'd
</span><span>
</span><span>'d: 'e
</span><span>'c: 'e
</span><span>
</span><span>'a: 'e
</span><span>'b: 'e
</span></code></pre></div></article></main><footer><br><div id=footer-container><i><a href=/internal/test>Q.E.D.</a></i></div><br></footer><script defer src=https://noteoverflow.github.io/js/script.js></script><div class=comments></div>