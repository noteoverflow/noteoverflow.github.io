<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="index, follow" name=robots><link href=https://noteoverflow.github.io/rss.xml rel=alternate title=RSS type=application/rss+xml><title>noteoverflow | Polymorphism in Rust</title><link as=style href=https://noteoverflow.github.io/css/style.css rel=preload><link crossorigin href=https://noteoverflow.github.io/css/reset-min.css rel=stylesheet><link crossorigin href=https://noteoverflow.github.io/css/suCSS-min.css rel=stylesheet><link href=https://noteoverflow.github.io/css/style.css rel=stylesheet><link href=https://noteoverflow.github.io/css/custom.css rel=stylesheet><link href=https://noteoverflow.github.io/img/favicon.ico rel=icon><body><nav id=nav-bar><a href=/posts> [post] </a><a href=/pinned> [pin] </a><a href=/tags> [tag] </a><a href=/> [self] </a> Â  <div aria-label="Toggle theme" class=theme-toggle data-icon-base=https://noteoverflow.github.io/icons.svg data-icon-dark=#darkMode data-icon-light=#lightMode data-sound-src=https://noteoverflow.github.io/click.ogg id=theme-toggle role=button tabindex=0><svg class=icon><use id=theme-icon></use></svg></div></nav><main><article class=post><header class=post-header><time datetime=2024-08-05>Published on: <span class=accent-data>2024-08-05</span> </time><div class=post-tags><a class=tag href=/tags/rust>#rust </a><a class=tag href=/tags/programming>#programming </a><a class=tag href=/tags/effect-system>#effect-system </a></div><h1>Polymorphism in Rust</h1></header><details><summary><i>Table of content</i></summary> <div class=toc-container><ul><li><a href=https://noteoverflow.github.io/posts/polymorphism-in-rust/#effect-polymorphism>Effect polymorphism</a><li><a href=https://noteoverflow.github.io/posts/polymorphism-in-rust/#ownership-polymorphism>Ownership polymorphism</a></ul></div></details><div class=post-content><p>Every language has polymorphism functions. Some utilize dynamic interfaces, some invent generics and typeclass to overload behavories.<p>Rust has <em>both</em>.<p>In Rust, we have type parameters and traits. Rust really prefer generics over existential types. If one want to be <code>Debug</code>, just "generic" it:<pre class=language-rust data-lang=rust style=color:#ccc9c2;background-color:#212733><code class=language-rust data-lang=rust><span style=color:#ffa759>fn </span><span style=color:#ffd580>use_debug</span><span>&lt;A</span><span style=color:#ccc9c2cc>: </span><span>fmt</span><span style=color:#f29e74>::</span><span>Debug>(</span><span style=color:#fc6>a</span><span style=color:#ccc9c2cc>:</span><span> A)</span><span style=color:#ccc9c2cc>;
</span></code></pre><p>We also have <em>associated types</em>, <em>where clauses</em>, <em>impl types</em>, etc. These all lift our type to polymorphism. However, there still exists two kinds of polymorphism which are somewhat hard to achieve in Rust now.<h2 id=effect-polymorphism>Effect polymorphism</h2><p>It's somewhat hard to explain what effect is because <em>side-effects</em> is nearly everywhere and we can't live without it! Effects are everything except for function input/output. Think about errors, asynchrony, uncertainty. Think about it and try to guess what they correspond to in out daily programming.<p>Yes, they are <code>Result&lt;_></code>, <code>Future&lt;Output=_></code> and various kinds of containers. Now suppose you want to write some <code>fn</code> which performs some unknown effect:<pre class=language-rust data-lang=rust style=color:#ccc9c2;background-color:#212733><code class=language-rust data-lang=rust><span style=color:#ffa759>fn </span><span style=color:#ffd580>func</span><span>&lt;F>(</span><span style=color:#fc6>x</span><span style=color:#ccc9c2cc>: </span><span style=color:#ffa759>i32</span><span>) </span><span style=color:#ccc9c2cc>-> </span><span>F&lt;</span><span style=color:#ffa759>i32</span><span>></span><span style=color:#ccc9c2cc>;
</span></code></pre><p>Congratulations! we discovers <em>Higher-Kinded Types(HKT)</em>. But you may also have noticed that this is not enough since <code>Future</code> is a trait and we have no way of abstract traits. Apparently Rust does not like <em>Monads</em>. In Rust, abstracting effects is really really hard right now. If you want to write one API for both sync and async codes, I just suggest you to write two separate traits.<h2 id=ownership-polymorphism>Ownership polymorphism</h2><p>Another one is ownership, which is also ubiquitous in Rust. Suppose you want write some AST like:<pre class=language-rust data-lang=rust style=color:#ccc9c2;background-color:#212733><code class=language-rust data-lang=rust><span style=color:#ffa759>enum </span><span style=color:#73d0ff>Expr </span><span>{
</span><span>    Var(</span><span style=color:#5ccfe6;font-style:italic>String</span><span>)</span><span style=color:#ccc9c2cc>,
</span><span>    Call { f</span><span style=color:#ccc9c2cc>:</span><span> Expr</span><span style=color:#ccc9c2cc>,</span><span> args</span><span style=color:#ccc9c2cc>: </span><span style=color:#5ccfe6;font-style:italic>Vec</span><span>&lt;Expr> }</span><span style=color:#ccc9c2cc>,
</span><span>    Lambda { args</span><span style=color:#ccc9c2cc>: </span><span style=color:#5ccfe6;font-style:italic>Vec</span><span>&lt;Expr></span><span style=color:#ccc9c2cc>,</span><span> body</span><span style=color:#ccc9c2cc>:</span><span> Expr }
</span><span>}
</span></code></pre><p>Apparently this does not compile since <code>Expr</code> is not <code>Sized</code>. We have to add some ownership for every recurrent position. For example:<pre class=language-rust data-lang=rust style=color:#ccc9c2;background-color:#212733><code class=language-rust data-lang=rust><span style=color:#ffa759>enum </span><span style=color:#73d0ff>Expr </span><span>{
</span><span>    </span><span style=color:#5c6773;font-style:italic>//...
</span><span>    Call { f</span><span style=color:#ccc9c2cc>: </span><span style=color:#5ccfe6;font-style:italic>Box</span><span>&lt;Expr></span><span style=color:#ccc9c2cc>, </span><span style=color:#5c6773;font-style:italic>/*..*/ </span><span>}
</span><span>    </span><span style=color:#5c6773;font-style:italic>//...
</span><span>}
</span></code></pre><p>However, <code>Box</code> has exclusive ownership, what about <code>Rc</code> or even <code>Arc</code>? You can just abstract the whole recurrent type as:<pre class=language-rust data-lang=rust style=color:#ccc9c2;background-color:#212733><code class=language-rust data-lang=rust><span style=color:#ffa759>enum </span><span style=color:#73d0ff>Expr</span><span>&lt;This> {
</span><span>    Call { f</span><span style=color:#ccc9c2cc>:</span><span> This</span><span style=color:#ccc9c2cc>,</span><span> args</span><span style=color:#ccc9c2cc>: </span><span style=color:#5ccfe6;font-style:italic>Vec</span><span>&lt;This> }
</span><span>}
</span><span>
</span><span style=color:#ffa759>type </span><span style=color:#73d0ff>Exprs </span><span style=color:#f29e74>= </span><span>Expr&lt;Rc&lt;Expr&lt;</span><span style=color:#f33>???</span><span style=color:#f29e74>>>>
</span></code></pre><p><code>Expr</code> is a fixpoint! This way we now have infinite type.<p>How about just abstract HKT?<pre class=language-rust data-lang=rust style=color:#ccc9c2;background-color:#212733><code class=language-rust data-lang=rust><span style=color:#ffa759>pub trait </span><span style=color:#73d0ff>Kind </span><span>{
</span><span>    </span><span style=color:#ffa759>type </span><span style=color:#73d0ff>F</span><span style=color:#f29e74>&lt;</span><span>T</span><span style=color:#f29e74>></span><span style=color:#ccc9c2cc>;
</span><span>}
</span><span>
</span><span style=color:#ffa759>enum </span><span style=color:#73d0ff>Expr</span><span>&lt;K: Kind> {
</span><span>    Call { f</span><span style=color:#ccc9c2cc>: </span><span>K</span><span style=color:#f29e74>::</span><span>F&lt;</span><span style=color:#ffa759>Self</span><span>></span><span style=color:#ccc9c2cc>,</span><span> args</span><span style=color:#ccc9c2cc>: </span><span style=color:#5ccfe6;font-style:italic>Vec</span><span>&lt;</span><span style=color:#ffa759>K</span><span style=color:#f29e74>::</span><span>F&lt;</span><span style=color:#ffa759>Self</span><span>>> }</span><span style=color:#ccc9c2cc>,
</span><span>}
</span></code></pre><p>HKTs are really useful on abstracting <code>* -> *</code> types!<p>I believe in the future, we can have effect polymorphism with <code>Coroutine</code> one-shot algebraic effects and ownership polymorphism with <em>GAT</em> and <em>impl type</em> alias.</div></article></main><footer><br><div id=footer-container><i><a href=/internal/test>Q.E.D.</a></i></div><br></footer><script defer src=https://noteoverflow.github.io/js/script.js></script><div class=comments></div>